// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.31.1
// source: il2cpp.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export interface ProtoClassInfo {
  namespaze: string;
  clazz: string;
  generics: ProtoTypeInfo[];
}

export interface ProtoStructInfo {
  clazz: ProtoClassInfo | undefined;
  fieldOffsets: { [key: number]: ProtoFieldInfo };
}

export interface ProtoStructInfo_FieldOffsetsEntry {
  key: number;
  value: ProtoFieldInfo | undefined;
}

export interface ProtoArrayInfo {
  memberType: ProtoTypeInfo | undefined;
}

export interface ProtoGenericInfo {
  genericHandle: bigint;
  name: string;
}

export interface ProtoEnumInfo {
  clazz: ProtoClassInfo | undefined;
  valueType: ProtoTypeInfo_Primitive;
  values: { [key: string]: bigint };
}

export interface ProtoEnumInfo_ValuesEntry {
  key: string;
  value: bigint;
}

export interface ProtoTypeInfo {
  Info?:
    | { $case: "primitiveInfo"; primitiveInfo: ProtoTypeInfo_Primitive }
    | { $case: "arrayInfo"; arrayInfo: ProtoArrayInfo }
    | { $case: "structInfo"; structInfo: ProtoStructInfo }
    | { $case: "classInfo"; classInfo: ProtoClassInfo }
    | { $case: "genericInfo"; genericInfo: ProtoGenericInfo }
    | { $case: "enumInfo"; enumInfo: ProtoEnumInfo }
    | undefined;
  size: number;
  /** conflicts with bshook byref macro */
  byref: ProtoTypeInfo_Byref;
}

/** TODO: maybe add more primitives */
export enum ProtoTypeInfo_Primitive {
  BOOLEAN = 0,
  CHAR = 1,
  BYTE = 2,
  SHORT = 3,
  INT = 4,
  LONG = 5,
  FLOAT = 6,
  DOUBLE = 7,
  STRING = 8,
  TYPE = 9,
  /** PTR - TODO: maybe separate and add pointed to type */
  PTR = 10,
  VOID = 11,
  UNKNOWN = 12,
  UNRECOGNIZED = -1,
}

export function protoTypeInfo_PrimitiveFromJSON(object: any): ProtoTypeInfo_Primitive {
  switch (object) {
    case 0:
    case "BOOLEAN":
      return ProtoTypeInfo_Primitive.BOOLEAN;
    case 1:
    case "CHAR":
      return ProtoTypeInfo_Primitive.CHAR;
    case 2:
    case "BYTE":
      return ProtoTypeInfo_Primitive.BYTE;
    case 3:
    case "SHORT":
      return ProtoTypeInfo_Primitive.SHORT;
    case 4:
    case "INT":
      return ProtoTypeInfo_Primitive.INT;
    case 5:
    case "LONG":
      return ProtoTypeInfo_Primitive.LONG;
    case 6:
    case "FLOAT":
      return ProtoTypeInfo_Primitive.FLOAT;
    case 7:
    case "DOUBLE":
      return ProtoTypeInfo_Primitive.DOUBLE;
    case 8:
    case "STRING":
      return ProtoTypeInfo_Primitive.STRING;
    case 9:
    case "TYPE":
      return ProtoTypeInfo_Primitive.TYPE;
    case 10:
    case "PTR":
      return ProtoTypeInfo_Primitive.PTR;
    case 11:
    case "VOID":
      return ProtoTypeInfo_Primitive.VOID;
    case 12:
    case "UNKNOWN":
      return ProtoTypeInfo_Primitive.UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoTypeInfo_Primitive.UNRECOGNIZED;
  }
}

export function protoTypeInfo_PrimitiveToJSON(object: ProtoTypeInfo_Primitive): string {
  switch (object) {
    case ProtoTypeInfo_Primitive.BOOLEAN:
      return "BOOLEAN";
    case ProtoTypeInfo_Primitive.CHAR:
      return "CHAR";
    case ProtoTypeInfo_Primitive.BYTE:
      return "BYTE";
    case ProtoTypeInfo_Primitive.SHORT:
      return "SHORT";
    case ProtoTypeInfo_Primitive.INT:
      return "INT";
    case ProtoTypeInfo_Primitive.LONG:
      return "LONG";
    case ProtoTypeInfo_Primitive.FLOAT:
      return "FLOAT";
    case ProtoTypeInfo_Primitive.DOUBLE:
      return "DOUBLE";
    case ProtoTypeInfo_Primitive.STRING:
      return "STRING";
    case ProtoTypeInfo_Primitive.TYPE:
      return "TYPE";
    case ProtoTypeInfo_Primitive.PTR:
      return "PTR";
    case ProtoTypeInfo_Primitive.VOID:
      return "VOID";
    case ProtoTypeInfo_Primitive.UNKNOWN:
      return "UNKNOWN";
    case ProtoTypeInfo_Primitive.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProtoTypeInfo_Byref {
  NONE = 0,
  REF = 1,
  IN = 2,
  OUT = 3,
  UNRECOGNIZED = -1,
}

export function protoTypeInfo_ByrefFromJSON(object: any): ProtoTypeInfo_Byref {
  switch (object) {
    case 0:
    case "NONE":
      return ProtoTypeInfo_Byref.NONE;
    case 1:
    case "REF":
      return ProtoTypeInfo_Byref.REF;
    case 2:
    case "IN":
      return ProtoTypeInfo_Byref.IN;
    case 3:
    case "OUT":
      return ProtoTypeInfo_Byref.OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoTypeInfo_Byref.UNRECOGNIZED;
  }
}

export function protoTypeInfo_ByrefToJSON(object: ProtoTypeInfo_Byref): string {
  switch (object) {
    case ProtoTypeInfo_Byref.NONE:
      return "NONE";
    case ProtoTypeInfo_Byref.REF:
      return "REF";
    case ProtoTypeInfo_Byref.IN:
      return "IN";
    case ProtoTypeInfo_Byref.OUT:
      return "OUT";
    case ProtoTypeInfo_Byref.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** id = pointer address of info */
export interface ProtoFieldInfo {
  name: string;
  id: bigint;
  type:
    | ProtoTypeInfo
    | undefined;
  /** means the field cannot be set */
  literal: boolean;
}

export interface ProtoPropertyInfo {
  name: string;
  id: bigint;
  type: ProtoTypeInfo | undefined;
  getterId?: bigint | undefined;
  setterId?: bigint | undefined;
  backingFieldId?: bigint | undefined;
}

export interface ProtoMethodInfo {
  name: string;
  id: bigint;
  args: ProtoMethodInfo_Argument[];
  returnType: ProtoTypeInfo | undefined;
}

export interface ProtoMethodInfo_Argument {
  name: string;
  type: ProtoTypeInfo | undefined;
}

/** contains the class data in its entirety for non-primitives */
export interface ProtoClassDetails {
  clazz: ProtoClassInfo | undefined;
  fields: ProtoFieldInfo[];
  properties: ProtoPropertyInfo[];
  methods: ProtoMethodInfo[];
  staticFields: ProtoFieldInfo[];
  staticProperties: ProtoPropertyInfo[];
  staticMethods: ProtoMethodInfo[];
  interfaces: ProtoClassInfo[];
  parent?: ProtoClassDetails | undefined;
}

/** separate from payload because the typeInfo never needs to be nested */
export interface ProtoDataSegment {
  Data?:
    | //
    /** simpler than having another oneof for each primitive case */
    { $case: "primitiveData"; primitiveData: Uint8Array }
    | { $case: "arrayData"; arrayData: ProtoDataSegment_ArrayData }
    | { $case: "structData"; structData: ProtoDataSegment_StructData }
    | //
    /** object pointer */
    { $case: "classData"; classData: bigint }
    | undefined;
}

/** repeated fields aren't allowed directly in oneOf */
export interface ProtoDataSegment_ArrayData {
  data: ProtoDataSegment[];
}

export interface ProtoDataSegment_StructData {
  data: { [key: number]: ProtoDataSegment };
}

export interface ProtoDataSegment_StructData_DataEntry {
  key: number;
  value: ProtoDataSegment | undefined;
}

export interface ProtoDataPayload {
  typeInfo: ProtoTypeInfo | undefined;
  data: ProtoDataSegment | undefined;
}

function createBaseProtoClassInfo(): ProtoClassInfo {
  return { namespaze: "", clazz: "", generics: [] };
}

export const ProtoClassInfo: MessageFns<ProtoClassInfo> = {
  encode(message: ProtoClassInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespaze !== "") {
      writer.uint32(10).string(message.namespaze);
    }
    if (message.clazz !== "") {
      writer.uint32(18).string(message.clazz);
    }
    for (const v of message.generics) {
      ProtoTypeInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoClassInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoClassInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespaze = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.generics.push(ProtoTypeInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoClassInfo {
    return {
      namespaze: isSet(object.namespaze) ? globalThis.String(object.namespaze) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
      generics: globalThis.Array.isArray(object?.generics)
        ? object.generics.map((e: any) => ProtoTypeInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProtoClassInfo): unknown {
    const obj: any = {};
    if (message.namespaze !== "") {
      obj.namespaze = message.namespaze;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    if (message.generics?.length) {
      obj.generics = message.generics.map((e) => ProtoTypeInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoClassInfo>, I>>(base?: I): ProtoClassInfo {
    return ProtoClassInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoClassInfo>, I>>(object: I): ProtoClassInfo {
    const message = createBaseProtoClassInfo();
    message.namespaze = object.namespaze ?? "";
    message.clazz = object.clazz ?? "";
    message.generics = object.generics?.map((e) => ProtoTypeInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProtoStructInfo(): ProtoStructInfo {
  return { clazz: undefined, fieldOffsets: {} };
}

export const ProtoStructInfo: MessageFns<ProtoStructInfo> = {
  encode(message: ProtoStructInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clazz !== undefined) {
      ProtoClassInfo.encode(message.clazz, writer.uint32(10).fork()).join();
    }
    Object.entries(message.fieldOffsets).forEach(([key, value]) => {
      ProtoStructInfo_FieldOffsetsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoStructInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoStructInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clazz = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProtoStructInfo_FieldOffsetsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.fieldOffsets[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoStructInfo {
    return {
      clazz: isSet(object.clazz) ? ProtoClassInfo.fromJSON(object.clazz) : undefined,
      fieldOffsets: isObject(object.fieldOffsets)
        ? Object.entries(object.fieldOffsets).reduce<{ [key: number]: ProtoFieldInfo }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = ProtoFieldInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoStructInfo): unknown {
    const obj: any = {};
    if (message.clazz !== undefined) {
      obj.clazz = ProtoClassInfo.toJSON(message.clazz);
    }
    if (message.fieldOffsets) {
      const entries = Object.entries(message.fieldOffsets);
      if (entries.length > 0) {
        obj.fieldOffsets = {};
        entries.forEach(([k, v]) => {
          obj.fieldOffsets[k] = ProtoFieldInfo.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoStructInfo>, I>>(base?: I): ProtoStructInfo {
    return ProtoStructInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoStructInfo>, I>>(object: I): ProtoStructInfo {
    const message = createBaseProtoStructInfo();
    message.clazz = (object.clazz !== undefined && object.clazz !== null)
      ? ProtoClassInfo.fromPartial(object.clazz)
      : undefined;
    message.fieldOffsets = Object.entries(object.fieldOffsets ?? {}).reduce<{ [key: number]: ProtoFieldInfo }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = ProtoFieldInfo.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoStructInfo_FieldOffsetsEntry(): ProtoStructInfo_FieldOffsetsEntry {
  return { key: 0, value: undefined };
}

export const ProtoStructInfo_FieldOffsetsEntry: MessageFns<ProtoStructInfo_FieldOffsetsEntry> = {
  encode(message: ProtoStructInfo_FieldOffsetsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      ProtoFieldInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoStructInfo_FieldOffsetsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoStructInfo_FieldOffsetsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoFieldInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoStructInfo_FieldOffsetsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? ProtoFieldInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoStructInfo_FieldOffsetsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = ProtoFieldInfo.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoStructInfo_FieldOffsetsEntry>, I>>(
    base?: I,
  ): ProtoStructInfo_FieldOffsetsEntry {
    return ProtoStructInfo_FieldOffsetsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoStructInfo_FieldOffsetsEntry>, I>>(
    object: I,
  ): ProtoStructInfo_FieldOffsetsEntry {
    const message = createBaseProtoStructInfo_FieldOffsetsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoFieldInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoArrayInfo(): ProtoArrayInfo {
  return { memberType: undefined };
}

export const ProtoArrayInfo: MessageFns<ProtoArrayInfo> = {
  encode(message: ProtoArrayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.memberType !== undefined) {
      ProtoTypeInfo.encode(message.memberType, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoArrayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoArrayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.memberType = ProtoTypeInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoArrayInfo {
    return { memberType: isSet(object.memberType) ? ProtoTypeInfo.fromJSON(object.memberType) : undefined };
  },

  toJSON(message: ProtoArrayInfo): unknown {
    const obj: any = {};
    if (message.memberType !== undefined) {
      obj.memberType = ProtoTypeInfo.toJSON(message.memberType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoArrayInfo>, I>>(base?: I): ProtoArrayInfo {
    return ProtoArrayInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoArrayInfo>, I>>(object: I): ProtoArrayInfo {
    const message = createBaseProtoArrayInfo();
    message.memberType = (object.memberType !== undefined && object.memberType !== null)
      ? ProtoTypeInfo.fromPartial(object.memberType)
      : undefined;
    return message;
  },
};

function createBaseProtoGenericInfo(): ProtoGenericInfo {
  return { genericHandle: 0n, name: "" };
}

export const ProtoGenericInfo: MessageFns<ProtoGenericInfo> = {
  encode(message: ProtoGenericInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.genericHandle !== 0n) {
      if (BigInt.asUintN(64, message.genericHandle) !== message.genericHandle) {
        throw new globalThis.Error("value provided for field message.genericHandle of type uint64 too large");
      }
      writer.uint32(8).uint64(message.genericHandle);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoGenericInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoGenericInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.genericHandle = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoGenericInfo {
    return {
      genericHandle: isSet(object.genericHandle) ? BigInt(object.genericHandle) : 0n,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: ProtoGenericInfo): unknown {
    const obj: any = {};
    if (message.genericHandle !== 0n) {
      obj.genericHandle = message.genericHandle.toString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoGenericInfo>, I>>(base?: I): ProtoGenericInfo {
    return ProtoGenericInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoGenericInfo>, I>>(object: I): ProtoGenericInfo {
    const message = createBaseProtoGenericInfo();
    message.genericHandle = object.genericHandle ?? 0n;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseProtoEnumInfo(): ProtoEnumInfo {
  return { clazz: undefined, valueType: 0, values: {} };
}

export const ProtoEnumInfo: MessageFns<ProtoEnumInfo> = {
  encode(message: ProtoEnumInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clazz !== undefined) {
      ProtoClassInfo.encode(message.clazz, writer.uint32(10).fork()).join();
    }
    if (message.valueType !== 0) {
      writer.uint32(16).int32(message.valueType);
    }
    Object.entries(message.values).forEach(([key, value]) => {
      ProtoEnumInfo_ValuesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoEnumInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoEnumInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clazz = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.valueType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ProtoEnumInfo_ValuesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.values[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoEnumInfo {
    return {
      clazz: isSet(object.clazz) ? ProtoClassInfo.fromJSON(object.clazz) : undefined,
      valueType: isSet(object.valueType) ? protoTypeInfo_PrimitiveFromJSON(object.valueType) : 0,
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: bigint }>((acc, [key, value]) => {
          acc[key] = BigInt(value as string | number | bigint | boolean);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoEnumInfo): unknown {
    const obj: any = {};
    if (message.clazz !== undefined) {
      obj.clazz = ProtoClassInfo.toJSON(message.clazz);
    }
    if (message.valueType !== 0) {
      obj.valueType = protoTypeInfo_PrimitiveToJSON(message.valueType);
    }
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoEnumInfo>, I>>(base?: I): ProtoEnumInfo {
    return ProtoEnumInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoEnumInfo>, I>>(object: I): ProtoEnumInfo {
    const message = createBaseProtoEnumInfo();
    message.clazz = (object.clazz !== undefined && object.clazz !== null)
      ? ProtoClassInfo.fromPartial(object.clazz)
      : undefined;
    message.valueType = object.valueType ?? 0;
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: bigint }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = BigInt(value as string | number | bigint | boolean);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseProtoEnumInfo_ValuesEntry(): ProtoEnumInfo_ValuesEntry {
  return { key: "", value: 0n };
}

export const ProtoEnumInfo_ValuesEntry: MessageFns<ProtoEnumInfo_ValuesEntry> = {
  encode(message: ProtoEnumInfo_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0n) {
      if (BigInt.asIntN(64, message.value) !== message.value) {
        throw new globalThis.Error("value provided for field message.value of type int64 too large");
      }
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoEnumInfo_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoEnumInfo_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoEnumInfo_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? BigInt(object.value) : 0n,
    };
  },

  toJSON(message: ProtoEnumInfo_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0n) {
      obj.value = message.value.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoEnumInfo_ValuesEntry>, I>>(base?: I): ProtoEnumInfo_ValuesEntry {
    return ProtoEnumInfo_ValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoEnumInfo_ValuesEntry>, I>>(object: I): ProtoEnumInfo_ValuesEntry {
    const message = createBaseProtoEnumInfo_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0n;
    return message;
  },
};

function createBaseProtoTypeInfo(): ProtoTypeInfo {
  return { Info: undefined, size: 0, byref: 0 };
}

export const ProtoTypeInfo: MessageFns<ProtoTypeInfo> = {
  encode(message: ProtoTypeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.Info?.$case) {
      case "primitiveInfo":
        writer.uint32(8).int32(message.Info.primitiveInfo);
        break;
      case "arrayInfo":
        ProtoArrayInfo.encode(message.Info.arrayInfo, writer.uint32(18).fork()).join();
        break;
      case "structInfo":
        ProtoStructInfo.encode(message.Info.structInfo, writer.uint32(26).fork()).join();
        break;
      case "classInfo":
        ProtoClassInfo.encode(message.Info.classInfo, writer.uint32(34).fork()).join();
        break;
      case "genericInfo":
        ProtoGenericInfo.encode(message.Info.genericInfo, writer.uint32(42).fork()).join();
        break;
      case "enumInfo":
        ProtoEnumInfo.encode(message.Info.enumInfo, writer.uint32(50).fork()).join();
        break;
    }
    if (message.size !== 0) {
      writer.uint32(56).int32(message.size);
    }
    if (message.byref !== 0) {
      writer.uint32(64).int32(message.byref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoTypeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Info = { $case: "primitiveInfo", primitiveInfo: reader.int32() as any };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Info = { $case: "arrayInfo", arrayInfo: ProtoArrayInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Info = { $case: "structInfo", structInfo: ProtoStructInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.Info = { $case: "classInfo", classInfo: ProtoClassInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.Info = { $case: "genericInfo", genericInfo: ProtoGenericInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.Info = { $case: "enumInfo", enumInfo: ProtoEnumInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.size = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.byref = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoTypeInfo {
    return {
      Info: isSet(object.primitiveInfo)
        ? { $case: "primitiveInfo", primitiveInfo: protoTypeInfo_PrimitiveFromJSON(object.primitiveInfo) }
        : isSet(object.arrayInfo)
        ? { $case: "arrayInfo", arrayInfo: ProtoArrayInfo.fromJSON(object.arrayInfo) }
        : isSet(object.structInfo)
        ? { $case: "structInfo", structInfo: ProtoStructInfo.fromJSON(object.structInfo) }
        : isSet(object.classInfo)
        ? { $case: "classInfo", classInfo: ProtoClassInfo.fromJSON(object.classInfo) }
        : isSet(object.genericInfo)
        ? { $case: "genericInfo", genericInfo: ProtoGenericInfo.fromJSON(object.genericInfo) }
        : isSet(object.enumInfo)
        ? { $case: "enumInfo", enumInfo: ProtoEnumInfo.fromJSON(object.enumInfo) }
        : undefined,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      byref: isSet(object.byref) ? protoTypeInfo_ByrefFromJSON(object.byref) : 0,
    };
  },

  toJSON(message: ProtoTypeInfo): unknown {
    const obj: any = {};
    if (message.Info?.$case === "primitiveInfo") {
      obj.primitiveInfo = protoTypeInfo_PrimitiveToJSON(message.Info.primitiveInfo);
    } else if (message.Info?.$case === "arrayInfo") {
      obj.arrayInfo = ProtoArrayInfo.toJSON(message.Info.arrayInfo);
    } else if (message.Info?.$case === "structInfo") {
      obj.structInfo = ProtoStructInfo.toJSON(message.Info.structInfo);
    } else if (message.Info?.$case === "classInfo") {
      obj.classInfo = ProtoClassInfo.toJSON(message.Info.classInfo);
    } else if (message.Info?.$case === "genericInfo") {
      obj.genericInfo = ProtoGenericInfo.toJSON(message.Info.genericInfo);
    } else if (message.Info?.$case === "enumInfo") {
      obj.enumInfo = ProtoEnumInfo.toJSON(message.Info.enumInfo);
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.byref !== 0) {
      obj.byref = protoTypeInfo_ByrefToJSON(message.byref);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoTypeInfo>, I>>(base?: I): ProtoTypeInfo {
    return ProtoTypeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoTypeInfo>, I>>(object: I): ProtoTypeInfo {
    const message = createBaseProtoTypeInfo();
    switch (object.Info?.$case) {
      case "primitiveInfo": {
        if (object.Info?.primitiveInfo !== undefined && object.Info?.primitiveInfo !== null) {
          message.Info = { $case: "primitiveInfo", primitiveInfo: object.Info.primitiveInfo };
        }
        break;
      }
      case "arrayInfo": {
        if (object.Info?.arrayInfo !== undefined && object.Info?.arrayInfo !== null) {
          message.Info = { $case: "arrayInfo", arrayInfo: ProtoArrayInfo.fromPartial(object.Info.arrayInfo) };
        }
        break;
      }
      case "structInfo": {
        if (object.Info?.structInfo !== undefined && object.Info?.structInfo !== null) {
          message.Info = { $case: "structInfo", structInfo: ProtoStructInfo.fromPartial(object.Info.structInfo) };
        }
        break;
      }
      case "classInfo": {
        if (object.Info?.classInfo !== undefined && object.Info?.classInfo !== null) {
          message.Info = { $case: "classInfo", classInfo: ProtoClassInfo.fromPartial(object.Info.classInfo) };
        }
        break;
      }
      case "genericInfo": {
        if (object.Info?.genericInfo !== undefined && object.Info?.genericInfo !== null) {
          message.Info = { $case: "genericInfo", genericInfo: ProtoGenericInfo.fromPartial(object.Info.genericInfo) };
        }
        break;
      }
      case "enumInfo": {
        if (object.Info?.enumInfo !== undefined && object.Info?.enumInfo !== null) {
          message.Info = { $case: "enumInfo", enumInfo: ProtoEnumInfo.fromPartial(object.Info.enumInfo) };
        }
        break;
      }
    }
    message.size = object.size ?? 0;
    message.byref = object.byref ?? 0;
    return message;
  },
};

function createBaseProtoFieldInfo(): ProtoFieldInfo {
  return { name: "", id: 0n, type: undefined, literal: false };
}

export const ProtoFieldInfo: MessageFns<ProtoFieldInfo> = {
  encode(message: ProtoFieldInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    if (message.type !== undefined) {
      ProtoTypeInfo.encode(message.type, writer.uint32(26).fork()).join();
    }
    if (message.literal !== false) {
      writer.uint32(32).bool(message.literal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFieldInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFieldInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = ProtoTypeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.literal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFieldInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      type: isSet(object.type) ? ProtoTypeInfo.fromJSON(object.type) : undefined,
      literal: isSet(object.literal) ? globalThis.Boolean(object.literal) : false,
    };
  },

  toJSON(message: ProtoFieldInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.type !== undefined) {
      obj.type = ProtoTypeInfo.toJSON(message.type);
    }
    if (message.literal !== false) {
      obj.literal = message.literal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFieldInfo>, I>>(base?: I): ProtoFieldInfo {
    return ProtoFieldInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFieldInfo>, I>>(object: I): ProtoFieldInfo {
    const message = createBaseProtoFieldInfo();
    message.name = object.name ?? "";
    message.id = object.id ?? 0n;
    message.type = (object.type !== undefined && object.type !== null)
      ? ProtoTypeInfo.fromPartial(object.type)
      : undefined;
    message.literal = object.literal ?? false;
    return message;
  },
};

function createBaseProtoPropertyInfo(): ProtoPropertyInfo {
  return { name: "", id: 0n, type: undefined, getterId: undefined, setterId: undefined, backingFieldId: undefined };
}

export const ProtoPropertyInfo: MessageFns<ProtoPropertyInfo> = {
  encode(message: ProtoPropertyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    if (message.type !== undefined) {
      ProtoTypeInfo.encode(message.type, writer.uint32(26).fork()).join();
    }
    if (message.getterId !== undefined) {
      if (BigInt.asUintN(64, message.getterId) !== message.getterId) {
        throw new globalThis.Error("value provided for field message.getterId of type uint64 too large");
      }
      writer.uint32(32).uint64(message.getterId);
    }
    if (message.setterId !== undefined) {
      if (BigInt.asUintN(64, message.setterId) !== message.setterId) {
        throw new globalThis.Error("value provided for field message.setterId of type uint64 too large");
      }
      writer.uint32(40).uint64(message.setterId);
    }
    if (message.backingFieldId !== undefined) {
      if (BigInt.asUintN(64, message.backingFieldId) !== message.backingFieldId) {
        throw new globalThis.Error("value provided for field message.backingFieldId of type uint64 too large");
      }
      writer.uint32(48).uint64(message.backingFieldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoPropertyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoPropertyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = ProtoTypeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.getterId = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.setterId = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.backingFieldId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoPropertyInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      type: isSet(object.type) ? ProtoTypeInfo.fromJSON(object.type) : undefined,
      getterId: isSet(object.getterId) ? BigInt(object.getterId) : undefined,
      setterId: isSet(object.setterId) ? BigInt(object.setterId) : undefined,
      backingFieldId: isSet(object.backingFieldId) ? BigInt(object.backingFieldId) : undefined,
    };
  },

  toJSON(message: ProtoPropertyInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.type !== undefined) {
      obj.type = ProtoTypeInfo.toJSON(message.type);
    }
    if (message.getterId !== undefined) {
      obj.getterId = message.getterId.toString();
    }
    if (message.setterId !== undefined) {
      obj.setterId = message.setterId.toString();
    }
    if (message.backingFieldId !== undefined) {
      obj.backingFieldId = message.backingFieldId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoPropertyInfo>, I>>(base?: I): ProtoPropertyInfo {
    return ProtoPropertyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoPropertyInfo>, I>>(object: I): ProtoPropertyInfo {
    const message = createBaseProtoPropertyInfo();
    message.name = object.name ?? "";
    message.id = object.id ?? 0n;
    message.type = (object.type !== undefined && object.type !== null)
      ? ProtoTypeInfo.fromPartial(object.type)
      : undefined;
    message.getterId = object.getterId ?? undefined;
    message.setterId = object.setterId ?? undefined;
    message.backingFieldId = object.backingFieldId ?? undefined;
    return message;
  },
};

function createBaseProtoMethodInfo(): ProtoMethodInfo {
  return { name: "", id: 0n, args: [], returnType: undefined };
}

export const ProtoMethodInfo: MessageFns<ProtoMethodInfo> = {
  encode(message: ProtoMethodInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    for (const v of message.args) {
      ProtoMethodInfo_Argument.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.returnType !== undefined) {
      ProtoTypeInfo.encode(message.returnType, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoMethodInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoMethodInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(ProtoMethodInfo_Argument.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.returnType = ProtoTypeInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoMethodInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      args: globalThis.Array.isArray(object?.args)
        ? object.args.map((e: any) => ProtoMethodInfo_Argument.fromJSON(e))
        : [],
      returnType: isSet(object.returnType) ? ProtoTypeInfo.fromJSON(object.returnType) : undefined,
    };
  },

  toJSON(message: ProtoMethodInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => ProtoMethodInfo_Argument.toJSON(e));
    }
    if (message.returnType !== undefined) {
      obj.returnType = ProtoTypeInfo.toJSON(message.returnType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoMethodInfo>, I>>(base?: I): ProtoMethodInfo {
    return ProtoMethodInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoMethodInfo>, I>>(object: I): ProtoMethodInfo {
    const message = createBaseProtoMethodInfo();
    message.name = object.name ?? "";
    message.id = object.id ?? 0n;
    message.args = object.args?.map((e) => ProtoMethodInfo_Argument.fromPartial(e)) || [];
    message.returnType = (object.returnType !== undefined && object.returnType !== null)
      ? ProtoTypeInfo.fromPartial(object.returnType)
      : undefined;
    return message;
  },
};

function createBaseProtoMethodInfo_Argument(): ProtoMethodInfo_Argument {
  return { name: "", type: undefined };
}

export const ProtoMethodInfo_Argument: MessageFns<ProtoMethodInfo_Argument> = {
  encode(message: ProtoMethodInfo_Argument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      ProtoTypeInfo.encode(message.type, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoMethodInfo_Argument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoMethodInfo_Argument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = ProtoTypeInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoMethodInfo_Argument {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? ProtoTypeInfo.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: ProtoMethodInfo_Argument): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = ProtoTypeInfo.toJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoMethodInfo_Argument>, I>>(base?: I): ProtoMethodInfo_Argument {
    return ProtoMethodInfo_Argument.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoMethodInfo_Argument>, I>>(object: I): ProtoMethodInfo_Argument {
    const message = createBaseProtoMethodInfo_Argument();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? ProtoTypeInfo.fromPartial(object.type)
      : undefined;
    return message;
  },
};

function createBaseProtoClassDetails(): ProtoClassDetails {
  return {
    clazz: undefined,
    fields: [],
    properties: [],
    methods: [],
    staticFields: [],
    staticProperties: [],
    staticMethods: [],
    interfaces: [],
    parent: undefined,
  };
}

export const ProtoClassDetails: MessageFns<ProtoClassDetails> = {
  encode(message: ProtoClassDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clazz !== undefined) {
      ProtoClassInfo.encode(message.clazz, writer.uint32(10).fork()).join();
    }
    for (const v of message.fields) {
      ProtoFieldInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.properties) {
      ProtoPropertyInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.methods) {
      ProtoMethodInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.staticFields) {
      ProtoFieldInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.staticProperties) {
      ProtoPropertyInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.staticMethods) {
      ProtoMethodInfo.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.interfaces) {
      ProtoClassInfo.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.parent !== undefined) {
      ProtoClassDetails.encode(message.parent, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoClassDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoClassDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clazz = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields.push(ProtoFieldInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.properties.push(ProtoPropertyInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.methods.push(ProtoMethodInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.staticFields.push(ProtoFieldInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.staticProperties.push(ProtoPropertyInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.staticMethods.push(ProtoMethodInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.interfaces.push(ProtoClassInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.parent = ProtoClassDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoClassDetails {
    return {
      clazz: isSet(object.clazz) ? ProtoClassInfo.fromJSON(object.clazz) : undefined,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => ProtoFieldInfo.fromJSON(e)) : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => ProtoPropertyInfo.fromJSON(e))
        : [],
      methods: globalThis.Array.isArray(object?.methods)
        ? object.methods.map((e: any) => ProtoMethodInfo.fromJSON(e))
        : [],
      staticFields: globalThis.Array.isArray(object?.staticFields)
        ? object.staticFields.map((e: any) => ProtoFieldInfo.fromJSON(e))
        : [],
      staticProperties: globalThis.Array.isArray(object?.staticProperties)
        ? object.staticProperties.map((e: any) => ProtoPropertyInfo.fromJSON(e))
        : [],
      staticMethods: globalThis.Array.isArray(object?.staticMethods)
        ? object.staticMethods.map((e: any) => ProtoMethodInfo.fromJSON(e))
        : [],
      interfaces: globalThis.Array.isArray(object?.interfaces)
        ? object.interfaces.map((e: any) => ProtoClassInfo.fromJSON(e))
        : [],
      parent: isSet(object.parent) ? ProtoClassDetails.fromJSON(object.parent) : undefined,
    };
  },

  toJSON(message: ProtoClassDetails): unknown {
    const obj: any = {};
    if (message.clazz !== undefined) {
      obj.clazz = ProtoClassInfo.toJSON(message.clazz);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => ProtoFieldInfo.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => ProtoPropertyInfo.toJSON(e));
    }
    if (message.methods?.length) {
      obj.methods = message.methods.map((e) => ProtoMethodInfo.toJSON(e));
    }
    if (message.staticFields?.length) {
      obj.staticFields = message.staticFields.map((e) => ProtoFieldInfo.toJSON(e));
    }
    if (message.staticProperties?.length) {
      obj.staticProperties = message.staticProperties.map((e) => ProtoPropertyInfo.toJSON(e));
    }
    if (message.staticMethods?.length) {
      obj.staticMethods = message.staticMethods.map((e) => ProtoMethodInfo.toJSON(e));
    }
    if (message.interfaces?.length) {
      obj.interfaces = message.interfaces.map((e) => ProtoClassInfo.toJSON(e));
    }
    if (message.parent !== undefined) {
      obj.parent = ProtoClassDetails.toJSON(message.parent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoClassDetails>, I>>(base?: I): ProtoClassDetails {
    return ProtoClassDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoClassDetails>, I>>(object: I): ProtoClassDetails {
    const message = createBaseProtoClassDetails();
    message.clazz = (object.clazz !== undefined && object.clazz !== null)
      ? ProtoClassInfo.fromPartial(object.clazz)
      : undefined;
    message.fields = object.fields?.map((e) => ProtoFieldInfo.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => ProtoPropertyInfo.fromPartial(e)) || [];
    message.methods = object.methods?.map((e) => ProtoMethodInfo.fromPartial(e)) || [];
    message.staticFields = object.staticFields?.map((e) => ProtoFieldInfo.fromPartial(e)) || [];
    message.staticProperties = object.staticProperties?.map((e) => ProtoPropertyInfo.fromPartial(e)) || [];
    message.staticMethods = object.staticMethods?.map((e) => ProtoMethodInfo.fromPartial(e)) || [];
    message.interfaces = object.interfaces?.map((e) => ProtoClassInfo.fromPartial(e)) || [];
    message.parent = (object.parent !== undefined && object.parent !== null)
      ? ProtoClassDetails.fromPartial(object.parent)
      : undefined;
    return message;
  },
};

function createBaseProtoDataSegment(): ProtoDataSegment {
  return { Data: undefined };
}

export const ProtoDataSegment: MessageFns<ProtoDataSegment> = {
  encode(message: ProtoDataSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.Data?.$case) {
      case "primitiveData":
        writer.uint32(10).bytes(message.Data.primitiveData);
        break;
      case "arrayData":
        ProtoDataSegment_ArrayData.encode(message.Data.arrayData, writer.uint32(18).fork()).join();
        break;
      case "structData":
        ProtoDataSegment_StructData.encode(message.Data.structData, writer.uint32(26).fork()).join();
        break;
      case "classData":
        if (BigInt.asUintN(64, message.Data.classData) !== message.Data.classData) {
          throw new globalThis.Error("value provided for field message.Data.classData of type uint64 too large");
        }
        writer.uint32(32).uint64(message.Data.classData);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDataSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDataSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Data = { $case: "primitiveData", primitiveData: reader.bytes() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Data = { $case: "arrayData", arrayData: ProtoDataSegment_ArrayData.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Data = {
            $case: "structData",
            structData: ProtoDataSegment_StructData.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.Data = { $case: "classData", classData: reader.uint64() as bigint };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDataSegment {
    return {
      Data: isSet(object.primitiveData)
        ? { $case: "primitiveData", primitiveData: bytesFromBase64(object.primitiveData) }
        : isSet(object.arrayData)
        ? { $case: "arrayData", arrayData: ProtoDataSegment_ArrayData.fromJSON(object.arrayData) }
        : isSet(object.structData)
        ? { $case: "structData", structData: ProtoDataSegment_StructData.fromJSON(object.structData) }
        : isSet(object.classData)
        ? { $case: "classData", classData: BigInt(object.classData) }
        : undefined,
    };
  },

  toJSON(message: ProtoDataSegment): unknown {
    const obj: any = {};
    if (message.Data?.$case === "primitiveData") {
      obj.primitiveData = base64FromBytes(message.Data.primitiveData);
    } else if (message.Data?.$case === "arrayData") {
      obj.arrayData = ProtoDataSegment_ArrayData.toJSON(message.Data.arrayData);
    } else if (message.Data?.$case === "structData") {
      obj.structData = ProtoDataSegment_StructData.toJSON(message.Data.structData);
    } else if (message.Data?.$case === "classData") {
      obj.classData = message.Data.classData.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDataSegment>, I>>(base?: I): ProtoDataSegment {
    return ProtoDataSegment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDataSegment>, I>>(object: I): ProtoDataSegment {
    const message = createBaseProtoDataSegment();
    switch (object.Data?.$case) {
      case "primitiveData": {
        if (object.Data?.primitiveData !== undefined && object.Data?.primitiveData !== null) {
          message.Data = { $case: "primitiveData", primitiveData: object.Data.primitiveData };
        }
        break;
      }
      case "arrayData": {
        if (object.Data?.arrayData !== undefined && object.Data?.arrayData !== null) {
          message.Data = {
            $case: "arrayData",
            arrayData: ProtoDataSegment_ArrayData.fromPartial(object.Data.arrayData),
          };
        }
        break;
      }
      case "structData": {
        if (object.Data?.structData !== undefined && object.Data?.structData !== null) {
          message.Data = {
            $case: "structData",
            structData: ProtoDataSegment_StructData.fromPartial(object.Data.structData),
          };
        }
        break;
      }
      case "classData": {
        if (object.Data?.classData !== undefined && object.Data?.classData !== null) {
          message.Data = { $case: "classData", classData: object.Data.classData };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseProtoDataSegment_ArrayData(): ProtoDataSegment_ArrayData {
  return { data: [] };
}

export const ProtoDataSegment_ArrayData: MessageFns<ProtoDataSegment_ArrayData> = {
  encode(message: ProtoDataSegment_ArrayData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      ProtoDataSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDataSegment_ArrayData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDataSegment_ArrayData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(ProtoDataSegment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDataSegment_ArrayData {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => ProtoDataSegment.fromJSON(e)) : [],
    };
  },

  toJSON(message: ProtoDataSegment_ArrayData): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => ProtoDataSegment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDataSegment_ArrayData>, I>>(base?: I): ProtoDataSegment_ArrayData {
    return ProtoDataSegment_ArrayData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDataSegment_ArrayData>, I>>(object: I): ProtoDataSegment_ArrayData {
    const message = createBaseProtoDataSegment_ArrayData();
    message.data = object.data?.map((e) => ProtoDataSegment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProtoDataSegment_StructData(): ProtoDataSegment_StructData {
  return { data: {} };
}

export const ProtoDataSegment_StructData: MessageFns<ProtoDataSegment_StructData> = {
  encode(message: ProtoDataSegment_StructData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.data).forEach(([key, value]) => {
      ProtoDataSegment_StructData_DataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDataSegment_StructData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDataSegment_StructData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = ProtoDataSegment_StructData_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.data[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDataSegment_StructData {
    return {
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: number]: ProtoDataSegment }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = ProtoDataSegment.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoDataSegment_StructData): unknown {
    const obj: any = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = ProtoDataSegment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDataSegment_StructData>, I>>(base?: I): ProtoDataSegment_StructData {
    return ProtoDataSegment_StructData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDataSegment_StructData>, I>>(object: I): ProtoDataSegment_StructData {
    const message = createBaseProtoDataSegment_StructData();
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: number]: ProtoDataSegment }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = ProtoDataSegment.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoDataSegment_StructData_DataEntry(): ProtoDataSegment_StructData_DataEntry {
  return { key: 0, value: undefined };
}

export const ProtoDataSegment_StructData_DataEntry: MessageFns<ProtoDataSegment_StructData_DataEntry> = {
  encode(message: ProtoDataSegment_StructData_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      ProtoDataSegment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDataSegment_StructData_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDataSegment_StructData_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoDataSegment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDataSegment_StructData_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? ProtoDataSegment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoDataSegment_StructData_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = ProtoDataSegment.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDataSegment_StructData_DataEntry>, I>>(
    base?: I,
  ): ProtoDataSegment_StructData_DataEntry {
    return ProtoDataSegment_StructData_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDataSegment_StructData_DataEntry>, I>>(
    object: I,
  ): ProtoDataSegment_StructData_DataEntry {
    const message = createBaseProtoDataSegment_StructData_DataEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoDataSegment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoDataPayload(): ProtoDataPayload {
  return { typeInfo: undefined, data: undefined };
}

export const ProtoDataPayload: MessageFns<ProtoDataPayload> = {
  encode(message: ProtoDataPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeInfo !== undefined) {
      ProtoTypeInfo.encode(message.typeInfo, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      ProtoDataSegment.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDataPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDataPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.typeInfo = ProtoTypeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = ProtoDataSegment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDataPayload {
    return {
      typeInfo: isSet(object.typeInfo) ? ProtoTypeInfo.fromJSON(object.typeInfo) : undefined,
      data: isSet(object.data) ? ProtoDataSegment.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: ProtoDataPayload): unknown {
    const obj: any = {};
    if (message.typeInfo !== undefined) {
      obj.typeInfo = ProtoTypeInfo.toJSON(message.typeInfo);
    }
    if (message.data !== undefined) {
      obj.data = ProtoDataSegment.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDataPayload>, I>>(base?: I): ProtoDataPayload {
    return ProtoDataPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDataPayload>, I>>(object: I): ProtoDataPayload {
    const message = createBaseProtoDataPayload();
    message.typeInfo = (object.typeInfo !== undefined && object.typeInfo !== null)
      ? ProtoTypeInfo.fromPartial(object.typeInfo)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? ProtoDataSegment.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
