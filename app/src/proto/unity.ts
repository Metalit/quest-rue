// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.31.1
// source: unity.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ProtoClassInfo } from "./il2cpp";

export const protobufPackage = "";

export interface ProtoObject {
  address: bigint;
  name: string;
  classInfo: ProtoClassInfo | undefined;
}

export interface ProtoComponent {
  address: bigint;
  name: string;
  /** pointer address */
  gameObject: bigint;
  classInfo: ProtoClassInfo | undefined;
}

export interface ProtoTransform {
  address: bigint;
  childCount: number;
  siblingIdx: number;
  /** transform address */
  parent: bigint;
}

export interface ProtoGameObject {
  address: bigint;
  name: string;
  transform: ProtoTransform | undefined;
  active: boolean;
  layer: number;
  scene: number;
  instanceId: number;
  tag: string;
}

export interface ProtoScene {
  handle: number;
  loaded: boolean;
  name: string;
  rootCount: number;
  active: boolean;
}

function createBaseProtoObject(): ProtoObject {
  return { address: BigInt("0"), name: "", classInfo: undefined };
}

export const ProtoObject: MessageFns<ProtoObject> = {
  encode(message: ProtoObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.classInfo !== undefined) {
      ProtoClassInfo.encode(message.classInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.classInfo = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoObject {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      classInfo: isSet(object.classInfo) ? ProtoClassInfo.fromJSON(object.classInfo) : undefined,
    };
  },

  toJSON(message: ProtoObject): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.classInfo !== undefined) {
      obj.classInfo = ProtoClassInfo.toJSON(message.classInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoObject>, I>>(base?: I): ProtoObject {
    return ProtoObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoObject>, I>>(object: I): ProtoObject {
    const message = createBaseProtoObject();
    message.address = object.address ?? BigInt("0");
    message.name = object.name ?? "";
    message.classInfo = (object.classInfo !== undefined && object.classInfo !== null)
      ? ProtoClassInfo.fromPartial(object.classInfo)
      : undefined;
    return message;
  },
};

function createBaseProtoComponent(): ProtoComponent {
  return { address: BigInt("0"), name: "", gameObject: BigInt("0"), classInfo: undefined };
}

export const ProtoComponent: MessageFns<ProtoComponent> = {
  encode(message: ProtoComponent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.gameObject !== BigInt("0")) {
      if (BigInt.asUintN(64, message.gameObject) !== message.gameObject) {
        throw new globalThis.Error("value provided for field message.gameObject of type uint64 too large");
      }
      writer.uint32(24).uint64(message.gameObject);
    }
    if (message.classInfo !== undefined) {
      ProtoClassInfo.encode(message.classInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoComponent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gameObject = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.classInfo = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoComponent {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      gameObject: isSet(object.gameObject) ? BigInt(object.gameObject) : BigInt("0"),
      classInfo: isSet(object.classInfo) ? ProtoClassInfo.fromJSON(object.classInfo) : undefined,
    };
  },

  toJSON(message: ProtoComponent): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.gameObject !== BigInt("0")) {
      obj.gameObject = message.gameObject.toString();
    }
    if (message.classInfo !== undefined) {
      obj.classInfo = ProtoClassInfo.toJSON(message.classInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoComponent>, I>>(base?: I): ProtoComponent {
    return ProtoComponent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoComponent>, I>>(object: I): ProtoComponent {
    const message = createBaseProtoComponent();
    message.address = object.address ?? BigInt("0");
    message.name = object.name ?? "";
    message.gameObject = object.gameObject ?? BigInt("0");
    message.classInfo = (object.classInfo !== undefined && object.classInfo !== null)
      ? ProtoClassInfo.fromPartial(object.classInfo)
      : undefined;
    return message;
  },
};

function createBaseProtoTransform(): ProtoTransform {
  return { address: BigInt("0"), childCount: 0, siblingIdx: 0, parent: BigInt("0") };
}

export const ProtoTransform: MessageFns<ProtoTransform> = {
  encode(message: ProtoTransform, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.childCount !== 0) {
      writer.uint32(16).int32(message.childCount);
    }
    if (message.siblingIdx !== 0) {
      writer.uint32(24).int32(message.siblingIdx);
    }
    if (message.parent !== BigInt("0")) {
      if (BigInt.asUintN(64, message.parent) !== message.parent) {
        throw new globalThis.Error("value provided for field message.parent of type uint64 too large");
      }
      writer.uint32(32).uint64(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoTransform {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoTransform();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.childCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.siblingIdx = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parent = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoTransform {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      childCount: isSet(object.childCount) ? globalThis.Number(object.childCount) : 0,
      siblingIdx: isSet(object.siblingIdx) ? globalThis.Number(object.siblingIdx) : 0,
      parent: isSet(object.parent) ? BigInt(object.parent) : BigInt("0"),
    };
  },

  toJSON(message: ProtoTransform): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.childCount !== 0) {
      obj.childCount = Math.round(message.childCount);
    }
    if (message.siblingIdx !== 0) {
      obj.siblingIdx = Math.round(message.siblingIdx);
    }
    if (message.parent !== BigInt("0")) {
      obj.parent = message.parent.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoTransform>, I>>(base?: I): ProtoTransform {
    return ProtoTransform.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoTransform>, I>>(object: I): ProtoTransform {
    const message = createBaseProtoTransform();
    message.address = object.address ?? BigInt("0");
    message.childCount = object.childCount ?? 0;
    message.siblingIdx = object.siblingIdx ?? 0;
    message.parent = object.parent ?? BigInt("0");
    return message;
  },
};

function createBaseProtoGameObject(): ProtoGameObject {
  return {
    address: BigInt("0"),
    name: "",
    transform: undefined,
    active: false,
    layer: 0,
    scene: 0,
    instanceId: 0,
    tag: "",
  };
}

export const ProtoGameObject: MessageFns<ProtoGameObject> = {
  encode(message: ProtoGameObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.transform !== undefined) {
      ProtoTransform.encode(message.transform, writer.uint32(26).fork()).join();
    }
    if (message.active !== false) {
      writer.uint32(32).bool(message.active);
    }
    if (message.layer !== 0) {
      writer.uint32(40).int32(message.layer);
    }
    if (message.scene !== 0) {
      writer.uint32(48).int32(message.scene);
    }
    if (message.instanceId !== 0) {
      writer.uint32(56).int32(message.instanceId);
    }
    if (message.tag !== "") {
      writer.uint32(66).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoGameObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoGameObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transform = ProtoTransform.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.layer = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scene = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.instanceId = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoGameObject {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      transform: isSet(object.transform) ? ProtoTransform.fromJSON(object.transform) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      layer: isSet(object.layer) ? globalThis.Number(object.layer) : 0,
      scene: isSet(object.scene) ? globalThis.Number(object.scene) : 0,
      instanceId: isSet(object.instanceId) ? globalThis.Number(object.instanceId) : 0,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: ProtoGameObject): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.transform !== undefined) {
      obj.transform = ProtoTransform.toJSON(message.transform);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.layer !== 0) {
      obj.layer = Math.round(message.layer);
    }
    if (message.scene !== 0) {
      obj.scene = Math.round(message.scene);
    }
    if (message.instanceId !== 0) {
      obj.instanceId = Math.round(message.instanceId);
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoGameObject>, I>>(base?: I): ProtoGameObject {
    return ProtoGameObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoGameObject>, I>>(object: I): ProtoGameObject {
    const message = createBaseProtoGameObject();
    message.address = object.address ?? BigInt("0");
    message.name = object.name ?? "";
    message.transform = (object.transform !== undefined && object.transform !== null)
      ? ProtoTransform.fromPartial(object.transform)
      : undefined;
    message.active = object.active ?? false;
    message.layer = object.layer ?? 0;
    message.scene = object.scene ?? 0;
    message.instanceId = object.instanceId ?? 0;
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseProtoScene(): ProtoScene {
  return { handle: 0, loaded: false, name: "", rootCount: 0, active: false };
}

export const ProtoScene: MessageFns<ProtoScene> = {
  encode(message: ProtoScene, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handle !== 0) {
      writer.uint32(8).int32(message.handle);
    }
    if (message.loaded !== false) {
      writer.uint32(16).bool(message.loaded);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.rootCount !== 0) {
      writer.uint32(32).int32(message.rootCount);
    }
    if (message.active !== false) {
      writer.uint32(40).bool(message.active);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoScene {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoScene();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.handle = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.loaded = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rootCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoScene {
    return {
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
      loaded: isSet(object.loaded) ? globalThis.Boolean(object.loaded) : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      rootCount: isSet(object.rootCount) ? globalThis.Number(object.rootCount) : 0,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
    };
  },

  toJSON(message: ProtoScene): unknown {
    const obj: any = {};
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    if (message.loaded !== false) {
      obj.loaded = message.loaded;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.rootCount !== 0) {
      obj.rootCount = Math.round(message.rootCount);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoScene>, I>>(base?: I): ProtoScene {
    return ProtoScene.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoScene>, I>>(object: I): ProtoScene {
    const message = createBaseProtoScene();
    message.handle = object.handle ?? 0;
    message.loaded = object.loaded ?? false;
    message.name = object.name ?? "";
    message.rootCount = object.rootCount ?? 0;
    message.active = object.active ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
