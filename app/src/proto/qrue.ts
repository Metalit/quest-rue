// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.31.1
// source: qrue.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ProtoClassDetails, ProtoClassInfo, ProtoDataPayload, ProtoDataSegment, ProtoTypeInfo } from "./il2cpp";
import { ProtoComponent, ProtoGameObject, ProtoObject, ProtoScene } from "./unity";

export const protobufPackage = "";

export interface SetField {
  fieldId: bigint;
  inst: ProtoDataPayload | undefined;
  value: ProtoDataPayload | undefined;
}

export interface SetFieldResult {
  fieldId: bigint;
}

export interface GetField {
  fieldId: bigint;
  inst: ProtoDataPayload | undefined;
}

export interface GetFieldResult {
  fieldId: bigint;
  value: ProtoDataPayload | undefined;
}

export interface InvokeMethod {
  methodId: bigint;
  inst: ProtoDataPayload | undefined;
  generics: ProtoTypeInfo[];
  args: ProtoDataPayload[];
}

export interface InvokeMethodResult {
  status: InvokeMethodResult_Status;
  methodId: bigint;
  result:
    | ProtoDataPayload
    | undefined;
  /** map from parameter index */
  byrefChanges: { [key: number]: ProtoDataPayload };
  /** nullable */
  error?: string | undefined;
}

export enum InvokeMethodResult_Status {
  ERR = 0,
  OK = 1,
  UNRECOGNIZED = -1,
}

export function invokeMethodResult_StatusFromJSON(object: any): InvokeMethodResult_Status {
  switch (object) {
    case 0:
    case "ERR":
      return InvokeMethodResult_Status.ERR;
    case 1:
    case "OK":
      return InvokeMethodResult_Status.OK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvokeMethodResult_Status.UNRECOGNIZED;
  }
}

export function invokeMethodResult_StatusToJSON(object: InvokeMethodResult_Status): string {
  switch (object) {
    case InvokeMethodResult_Status.ERR:
      return "ERR";
    case InvokeMethodResult_Status.OK:
      return "OK";
    case InvokeMethodResult_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InvokeMethodResult_ByrefChangesEntry {
  key: number;
  value: ProtoDataPayload | undefined;
}

export interface SearchObjects {
  componentClass:
    | ProtoClassInfo
    | undefined;
  /** nullable */
  name?: string | undefined;
}

export interface SearchObjectsResult {
  objects: ProtoObject[];
}

export interface GetAllGameObjects {
}

export interface GetAllGameObjectsResult {
  objects: ProtoGameObject[];
  scenes: ProtoScene[];
}

export interface GetGameObjectComponents {
  /** GameObject address */
  address: bigint;
}

export interface GetGameObjectComponentsResult {
  components: ProtoComponent[];
}

export interface ReadMemory {
  address: bigint;
  size: bigint;
}

export interface ReadMemoryResult {
  status: ReadMemoryResult_Status;
  address: bigint;
  data: Uint8Array;
}

export enum ReadMemoryResult_Status {
  ERR = 0,
  OK = 1,
  UNRECOGNIZED = -1,
}

export function readMemoryResult_StatusFromJSON(object: any): ReadMemoryResult_Status {
  switch (object) {
    case 0:
    case "ERR":
      return ReadMemoryResult_Status.ERR;
    case 1:
    case "OK":
      return ReadMemoryResult_Status.OK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReadMemoryResult_Status.UNRECOGNIZED;
  }
}

export function readMemoryResult_StatusToJSON(object: ReadMemoryResult_Status): string {
  switch (object) {
    case ReadMemoryResult_Status.ERR:
      return "ERR";
    case ReadMemoryResult_Status.OK:
      return "OK";
    case ReadMemoryResult_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WriteMemory {
  address: bigint;
  data: Uint8Array;
}

export interface WriteMemoryResult {
  status: WriteMemoryResult_Status;
  address: bigint;
  size: bigint;
}

export enum WriteMemoryResult_Status {
  ERR = 0,
  OK = 1,
  UNRECOGNIZED = -1,
}

export function writeMemoryResult_StatusFromJSON(object: any): WriteMemoryResult_Status {
  switch (object) {
    case 0:
    case "ERR":
      return WriteMemoryResult_Status.ERR;
    case 1:
    case "OK":
      return WriteMemoryResult_Status.OK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WriteMemoryResult_Status.UNRECOGNIZED;
  }
}

export function writeMemoryResult_StatusToJSON(object: WriteMemoryResult_Status): string {
  switch (object) {
    case WriteMemoryResult_Status.ERR:
      return "ERR";
    case WriteMemoryResult_Status.OK:
      return "OK";
    case WriteMemoryResult_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetClassDetails {
  classInfo: ProtoClassInfo | undefined;
}

export interface GetClassDetailsResult {
  classDetails: ProtoClassDetails | undefined;
}

export interface GetInstanceClass {
  address: bigint;
}

export interface GetInstanceClassResult {
  classInfo: ProtoClassInfo | undefined;
}

export interface GetInstanceValues {
  /** class or struct only */
  instance: ProtoDataPayload | undefined;
}

export interface GetInstanceValuesResult {
  values: GetInstanceValuesResult_ValuePair[];
}

export interface GetInstanceValuesResult_ValuePair {
  id: bigint;
  data: ProtoDataSegment | undefined;
}

export interface CreateGameObject {
  name: string;
  parent?: bigint | undefined;
}

export interface CreateGameObjectResult {
}

/** Returns GetListSafePtrAddressResult */
export interface AddSafePtrAddress {
  address: bigint;
  remove: boolean;
}

export interface GetSafePtrAddresses {
}

export interface GetSafePtrAddressesResult {
  addresses: GetSafePtrAddressesResult_AddressInfo[];
}

export interface GetSafePtrAddressesResult_AddressInfo {
  address: bigint;
  clazz: ProtoClassInfo | undefined;
}

export interface GetTypeComplete {
  namespaze?: string | undefined;
  clazz?: string | undefined;
}

export interface GetTypeCompleteResult {
  options: string[];
}

export interface PacketWrapper {
  queryResultId: bigint;
  Packet?:
    | { $case: "inputError"; inputError: string }
    | { $case: "setField"; setField: SetField }
    | { $case: "setFieldResult"; setFieldResult: SetFieldResult }
    | { $case: "getField"; getField: GetField }
    | { $case: "getFieldResult"; getFieldResult: GetFieldResult }
    | { $case: "invokeMethod"; invokeMethod: InvokeMethod }
    | { $case: "invokeMethodResult"; invokeMethodResult: InvokeMethodResult }
    | { $case: "searchObjects"; searchObjects: SearchObjects }
    | { $case: "searchObjectsResult"; searchObjectsResult: SearchObjectsResult }
    | { $case: "getAllGameObjects"; getAllGameObjects: GetAllGameObjects }
    | { $case: "getAllGameObjectsResult"; getAllGameObjectsResult: GetAllGameObjectsResult }
    | { $case: "getGameObjectComponents"; getGameObjectComponents: GetGameObjectComponents }
    | { $case: "getGameObjectComponentsResult"; getGameObjectComponentsResult: GetGameObjectComponentsResult }
    | { $case: "readMemory"; readMemory: ReadMemory }
    | { $case: "readMemoryResult"; readMemoryResult: ReadMemoryResult }
    | { $case: "writeMemory"; writeMemory: WriteMemory }
    | { $case: "writeMemoryResult"; writeMemoryResult: WriteMemoryResult }
    | { $case: "getClassDetails"; getClassDetails: GetClassDetails }
    | { $case: "getClassDetailsResult"; getClassDetailsResult: GetClassDetailsResult }
    | { $case: "getInstanceClass"; getInstanceClass: GetInstanceClass }
    | { $case: "getInstanceClassResult"; getInstanceClassResult: GetInstanceClassResult }
    | { $case: "getInstanceValues"; getInstanceValues: GetInstanceValues }
    | { $case: "getInstanceValuesResult"; getInstanceValuesResult: GetInstanceValuesResult }
    | { $case: "createGameObject"; createGameObject: CreateGameObject }
    | { $case: "createGameObjectResult"; createGameObjectResult: CreateGameObjectResult }
    | { $case: "addSafePtrAddress"; addSafePtrAddress: AddSafePtrAddress }
    | { $case: "getSafePtrAddresses"; getSafePtrAddresses: GetSafePtrAddresses }
    | { $case: "getSafePtrAddressesResult"; getSafePtrAddressesResult: GetSafePtrAddressesResult }
    | { $case: "getTypeComplete"; getTypeComplete: GetTypeComplete }
    | { $case: "getTypeCompleteResult"; getTypeCompleteResult: GetTypeCompleteResult }
    | undefined;
}

function createBaseSetField(): SetField {
  return { fieldId: BigInt("0"), inst: undefined, value: undefined };
}

export const SetField: MessageFns<SetField> = {
  encode(message: SetField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.fieldId) !== message.fieldId) {
        throw new globalThis.Error("value provided for field message.fieldId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.fieldId);
    }
    if (message.inst !== undefined) {
      ProtoDataPayload.encode(message.inst, writer.uint32(18).fork()).join();
    }
    if (message.value !== undefined) {
      ProtoDataPayload.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fieldId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inst = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetField {
    return {
      fieldId: isSet(object.fieldId) ? BigInt(object.fieldId) : BigInt("0"),
      inst: isSet(object.inst) ? ProtoDataPayload.fromJSON(object.inst) : undefined,
      value: isSet(object.value) ? ProtoDataPayload.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SetField): unknown {
    const obj: any = {};
    if (message.fieldId !== BigInt("0")) {
      obj.fieldId = message.fieldId.toString();
    }
    if (message.inst !== undefined) {
      obj.inst = ProtoDataPayload.toJSON(message.inst);
    }
    if (message.value !== undefined) {
      obj.value = ProtoDataPayload.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetField>, I>>(base?: I): SetField {
    return SetField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetField>, I>>(object: I): SetField {
    const message = createBaseSetField();
    message.fieldId = object.fieldId ?? BigInt("0");
    message.inst = (object.inst !== undefined && object.inst !== null)
      ? ProtoDataPayload.fromPartial(object.inst)
      : undefined;
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoDataPayload.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSetFieldResult(): SetFieldResult {
  return { fieldId: BigInt("0") };
}

export const SetFieldResult: MessageFns<SetFieldResult> = {
  encode(message: SetFieldResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.fieldId) !== message.fieldId) {
        throw new globalThis.Error("value provided for field message.fieldId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.fieldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetFieldResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetFieldResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fieldId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetFieldResult {
    return { fieldId: isSet(object.fieldId) ? BigInt(object.fieldId) : BigInt("0") };
  },

  toJSON(message: SetFieldResult): unknown {
    const obj: any = {};
    if (message.fieldId !== BigInt("0")) {
      obj.fieldId = message.fieldId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetFieldResult>, I>>(base?: I): SetFieldResult {
    return SetFieldResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetFieldResult>, I>>(object: I): SetFieldResult {
    const message = createBaseSetFieldResult();
    message.fieldId = object.fieldId ?? BigInt("0");
    return message;
  },
};

function createBaseGetField(): GetField {
  return { fieldId: BigInt("0"), inst: undefined };
}

export const GetField: MessageFns<GetField> = {
  encode(message: GetField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.fieldId) !== message.fieldId) {
        throw new globalThis.Error("value provided for field message.fieldId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.fieldId);
    }
    if (message.inst !== undefined) {
      ProtoDataPayload.encode(message.inst, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fieldId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inst = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetField {
    return {
      fieldId: isSet(object.fieldId) ? BigInt(object.fieldId) : BigInt("0"),
      inst: isSet(object.inst) ? ProtoDataPayload.fromJSON(object.inst) : undefined,
    };
  },

  toJSON(message: GetField): unknown {
    const obj: any = {};
    if (message.fieldId !== BigInt("0")) {
      obj.fieldId = message.fieldId.toString();
    }
    if (message.inst !== undefined) {
      obj.inst = ProtoDataPayload.toJSON(message.inst);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetField>, I>>(base?: I): GetField {
    return GetField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetField>, I>>(object: I): GetField {
    const message = createBaseGetField();
    message.fieldId = object.fieldId ?? BigInt("0");
    message.inst = (object.inst !== undefined && object.inst !== null)
      ? ProtoDataPayload.fromPartial(object.inst)
      : undefined;
    return message;
  },
};

function createBaseGetFieldResult(): GetFieldResult {
  return { fieldId: BigInt("0"), value: undefined };
}

export const GetFieldResult: MessageFns<GetFieldResult> = {
  encode(message: GetFieldResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.fieldId) !== message.fieldId) {
        throw new globalThis.Error("value provided for field message.fieldId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.fieldId);
    }
    if (message.value !== undefined) {
      ProtoDataPayload.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFieldResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFieldResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fieldId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFieldResult {
    return {
      fieldId: isSet(object.fieldId) ? BigInt(object.fieldId) : BigInt("0"),
      value: isSet(object.value) ? ProtoDataPayload.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetFieldResult): unknown {
    const obj: any = {};
    if (message.fieldId !== BigInt("0")) {
      obj.fieldId = message.fieldId.toString();
    }
    if (message.value !== undefined) {
      obj.value = ProtoDataPayload.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFieldResult>, I>>(base?: I): GetFieldResult {
    return GetFieldResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFieldResult>, I>>(object: I): GetFieldResult {
    const message = createBaseGetFieldResult();
    message.fieldId = object.fieldId ?? BigInt("0");
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoDataPayload.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInvokeMethod(): InvokeMethod {
  return { methodId: BigInt("0"), inst: undefined, generics: [], args: [] };
}

export const InvokeMethod: MessageFns<InvokeMethod> = {
  encode(message: InvokeMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.methodId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.methodId) !== message.methodId) {
        throw new globalThis.Error("value provided for field message.methodId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.methodId);
    }
    if (message.inst !== undefined) {
      ProtoDataPayload.encode(message.inst, writer.uint32(18).fork()).join();
    }
    for (const v of message.generics) {
      ProtoTypeInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.args) {
      ProtoDataPayload.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvokeMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.methodId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inst = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.generics.push(ProtoTypeInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.args.push(ProtoDataPayload.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeMethod {
    return {
      methodId: isSet(object.methodId) ? BigInt(object.methodId) : BigInt("0"),
      inst: isSet(object.inst) ? ProtoDataPayload.fromJSON(object.inst) : undefined,
      generics: globalThis.Array.isArray(object?.generics)
        ? object.generics.map((e: any) => ProtoTypeInfo.fromJSON(e))
        : [],
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => ProtoDataPayload.fromJSON(e)) : [],
    };
  },

  toJSON(message: InvokeMethod): unknown {
    const obj: any = {};
    if (message.methodId !== BigInt("0")) {
      obj.methodId = message.methodId.toString();
    }
    if (message.inst !== undefined) {
      obj.inst = ProtoDataPayload.toJSON(message.inst);
    }
    if (message.generics?.length) {
      obj.generics = message.generics.map((e) => ProtoTypeInfo.toJSON(e));
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => ProtoDataPayload.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeMethod>, I>>(base?: I): InvokeMethod {
    return InvokeMethod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeMethod>, I>>(object: I): InvokeMethod {
    const message = createBaseInvokeMethod();
    message.methodId = object.methodId ?? BigInt("0");
    message.inst = (object.inst !== undefined && object.inst !== null)
      ? ProtoDataPayload.fromPartial(object.inst)
      : undefined;
    message.generics = object.generics?.map((e) => ProtoTypeInfo.fromPartial(e)) || [];
    message.args = object.args?.map((e) => ProtoDataPayload.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvokeMethodResult(): InvokeMethodResult {
  return { status: 0, methodId: BigInt("0"), result: undefined, byrefChanges: {}, error: undefined };
}

export const InvokeMethodResult: MessageFns<InvokeMethodResult> = {
  encode(message: InvokeMethodResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.methodId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.methodId) !== message.methodId) {
        throw new globalThis.Error("value provided for field message.methodId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.methodId);
    }
    if (message.result !== undefined) {
      ProtoDataPayload.encode(message.result, writer.uint32(26).fork()).join();
    }
    Object.entries(message.byrefChanges).forEach(([key, value]) => {
      InvokeMethodResult_ByrefChangesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.error !== undefined) {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvokeMethodResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeMethodResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.methodId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = InvokeMethodResult_ByrefChangesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.byrefChanges[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeMethodResult {
    return {
      status: isSet(object.status) ? invokeMethodResult_StatusFromJSON(object.status) : 0,
      methodId: isSet(object.methodId) ? BigInt(object.methodId) : BigInt("0"),
      result: isSet(object.result) ? ProtoDataPayload.fromJSON(object.result) : undefined,
      byrefChanges: isObject(object.byrefChanges)
        ? Object.entries(object.byrefChanges).reduce<{ [key: number]: ProtoDataPayload }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = ProtoDataPayload.fromJSON(value);
          return acc;
        }, {})
        : {},
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: InvokeMethodResult): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = invokeMethodResult_StatusToJSON(message.status);
    }
    if (message.methodId !== BigInt("0")) {
      obj.methodId = message.methodId.toString();
    }
    if (message.result !== undefined) {
      obj.result = ProtoDataPayload.toJSON(message.result);
    }
    if (message.byrefChanges) {
      const entries = Object.entries(message.byrefChanges);
      if (entries.length > 0) {
        obj.byrefChanges = {};
        entries.forEach(([k, v]) => {
          obj.byrefChanges[k] = ProtoDataPayload.toJSON(v);
        });
      }
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeMethodResult>, I>>(base?: I): InvokeMethodResult {
    return InvokeMethodResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeMethodResult>, I>>(object: I): InvokeMethodResult {
    const message = createBaseInvokeMethodResult();
    message.status = object.status ?? 0;
    message.methodId = object.methodId ?? BigInt("0");
    message.result = (object.result !== undefined && object.result !== null)
      ? ProtoDataPayload.fromPartial(object.result)
      : undefined;
    message.byrefChanges = Object.entries(object.byrefChanges ?? {}).reduce<{ [key: number]: ProtoDataPayload }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = ProtoDataPayload.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseInvokeMethodResult_ByrefChangesEntry(): InvokeMethodResult_ByrefChangesEntry {
  return { key: 0, value: undefined };
}

export const InvokeMethodResult_ByrefChangesEntry: MessageFns<InvokeMethodResult_ByrefChangesEntry> = {
  encode(message: InvokeMethodResult_ByrefChangesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      ProtoDataPayload.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvokeMethodResult_ByrefChangesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeMethodResult_ByrefChangesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeMethodResult_ByrefChangesEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? ProtoDataPayload.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InvokeMethodResult_ByrefChangesEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = ProtoDataPayload.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeMethodResult_ByrefChangesEntry>, I>>(
    base?: I,
  ): InvokeMethodResult_ByrefChangesEntry {
    return InvokeMethodResult_ByrefChangesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeMethodResult_ByrefChangesEntry>, I>>(
    object: I,
  ): InvokeMethodResult_ByrefChangesEntry {
    const message = createBaseInvokeMethodResult_ByrefChangesEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoDataPayload.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSearchObjects(): SearchObjects {
  return { componentClass: undefined, name: undefined };
}

export const SearchObjects: MessageFns<SearchObjects> = {
  encode(message: SearchObjects, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.componentClass !== undefined) {
      ProtoClassInfo.encode(message.componentClass, writer.uint32(10).fork()).join();
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchObjects {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchObjects();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.componentClass = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchObjects {
    return {
      componentClass: isSet(object.componentClass) ? ProtoClassInfo.fromJSON(object.componentClass) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: SearchObjects): unknown {
    const obj: any = {};
    if (message.componentClass !== undefined) {
      obj.componentClass = ProtoClassInfo.toJSON(message.componentClass);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchObjects>, I>>(base?: I): SearchObjects {
    return SearchObjects.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchObjects>, I>>(object: I): SearchObjects {
    const message = createBaseSearchObjects();
    message.componentClass = (object.componentClass !== undefined && object.componentClass !== null)
      ? ProtoClassInfo.fromPartial(object.componentClass)
      : undefined;
    message.name = object.name ?? undefined;
    return message;
  },
};

function createBaseSearchObjectsResult(): SearchObjectsResult {
  return { objects: [] };
}

export const SearchObjectsResult: MessageFns<SearchObjectsResult> = {
  encode(message: SearchObjectsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.objects) {
      ProtoObject.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchObjectsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchObjectsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.objects.push(ProtoObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchObjectsResult {
    return {
      objects: globalThis.Array.isArray(object?.objects) ? object.objects.map((e: any) => ProtoObject.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchObjectsResult): unknown {
    const obj: any = {};
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => ProtoObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchObjectsResult>, I>>(base?: I): SearchObjectsResult {
    return SearchObjectsResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchObjectsResult>, I>>(object: I): SearchObjectsResult {
    const message = createBaseSearchObjectsResult();
    message.objects = object.objects?.map((e) => ProtoObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllGameObjects(): GetAllGameObjects {
  return {};
}

export const GetAllGameObjects: MessageFns<GetAllGameObjects> = {
  encode(_: GetAllGameObjects, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllGameObjects {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllGameObjects();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllGameObjects {
    return {};
  },

  toJSON(_: GetAllGameObjects): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllGameObjects>, I>>(base?: I): GetAllGameObjects {
    return GetAllGameObjects.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllGameObjects>, I>>(_: I): GetAllGameObjects {
    const message = createBaseGetAllGameObjects();
    return message;
  },
};

function createBaseGetAllGameObjectsResult(): GetAllGameObjectsResult {
  return { objects: [], scenes: [] };
}

export const GetAllGameObjectsResult: MessageFns<GetAllGameObjectsResult> = {
  encode(message: GetAllGameObjectsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.objects) {
      ProtoGameObject.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.scenes) {
      ProtoScene.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllGameObjectsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllGameObjectsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.objects.push(ProtoGameObject.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scenes.push(ProtoScene.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllGameObjectsResult {
    return {
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => ProtoGameObject.fromJSON(e))
        : [],
      scenes: globalThis.Array.isArray(object?.scenes) ? object.scenes.map((e: any) => ProtoScene.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetAllGameObjectsResult): unknown {
    const obj: any = {};
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => ProtoGameObject.toJSON(e));
    }
    if (message.scenes?.length) {
      obj.scenes = message.scenes.map((e) => ProtoScene.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllGameObjectsResult>, I>>(base?: I): GetAllGameObjectsResult {
    return GetAllGameObjectsResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllGameObjectsResult>, I>>(object: I): GetAllGameObjectsResult {
    const message = createBaseGetAllGameObjectsResult();
    message.objects = object.objects?.map((e) => ProtoGameObject.fromPartial(e)) || [];
    message.scenes = object.scenes?.map((e) => ProtoScene.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetGameObjectComponents(): GetGameObjectComponents {
  return { address: BigInt("0") };
}

export const GetGameObjectComponents: MessageFns<GetGameObjectComponents> = {
  encode(message: GetGameObjectComponents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGameObjectComponents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGameObjectComponents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGameObjectComponents {
    return { address: isSet(object.address) ? BigInt(object.address) : BigInt("0") };
  },

  toJSON(message: GetGameObjectComponents): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGameObjectComponents>, I>>(base?: I): GetGameObjectComponents {
    return GetGameObjectComponents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGameObjectComponents>, I>>(object: I): GetGameObjectComponents {
    const message = createBaseGetGameObjectComponents();
    message.address = object.address ?? BigInt("0");
    return message;
  },
};

function createBaseGetGameObjectComponentsResult(): GetGameObjectComponentsResult {
  return { components: [] };
}

export const GetGameObjectComponentsResult: MessageFns<GetGameObjectComponentsResult> = {
  encode(message: GetGameObjectComponentsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.components) {
      ProtoComponent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGameObjectComponentsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGameObjectComponentsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.components.push(ProtoComponent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGameObjectComponentsResult {
    return {
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => ProtoComponent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetGameObjectComponentsResult): unknown {
    const obj: any = {};
    if (message.components?.length) {
      obj.components = message.components.map((e) => ProtoComponent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGameObjectComponentsResult>, I>>(base?: I): GetGameObjectComponentsResult {
    return GetGameObjectComponentsResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGameObjectComponentsResult>, I>>(
    object: I,
  ): GetGameObjectComponentsResult {
    const message = createBaseGetGameObjectComponentsResult();
    message.components = object.components?.map((e) => ProtoComponent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReadMemory(): ReadMemory {
  return { address: BigInt("0"), size: BigInt("0") };
}

export const ReadMemory: MessageFns<ReadMemory> = {
  encode(message: ReadMemory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.size !== BigInt("0")) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(16).uint64(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadMemory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadMemory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadMemory {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      size: isSet(object.size) ? BigInt(object.size) : BigInt("0"),
    };
  },

  toJSON(message: ReadMemory): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.size !== BigInt("0")) {
      obj.size = message.size.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadMemory>, I>>(base?: I): ReadMemory {
    return ReadMemory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadMemory>, I>>(object: I): ReadMemory {
    const message = createBaseReadMemory();
    message.address = object.address ?? BigInt("0");
    message.size = object.size ?? BigInt("0");
    return message;
  },
};

function createBaseReadMemoryResult(): ReadMemoryResult {
  return { status: 0, address: BigInt("0"), data: new Uint8Array(0) };
}

export const ReadMemoryResult: MessageFns<ReadMemoryResult> = {
  encode(message: ReadMemoryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(16).uint64(message.address);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadMemoryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadMemoryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadMemoryResult {
    return {
      status: isSet(object.status) ? readMemoryResult_StatusFromJSON(object.status) : 0,
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ReadMemoryResult): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = readMemoryResult_StatusToJSON(message.status);
    }
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadMemoryResult>, I>>(base?: I): ReadMemoryResult {
    return ReadMemoryResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadMemoryResult>, I>>(object: I): ReadMemoryResult {
    const message = createBaseReadMemoryResult();
    message.status = object.status ?? 0;
    message.address = object.address ?? BigInt("0");
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWriteMemory(): WriteMemory {
  return { address: BigInt("0"), data: new Uint8Array(0) };
}

export const WriteMemory: MessageFns<WriteMemory> = {
  encode(message: WriteMemory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteMemory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteMemory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteMemory {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: WriteMemory): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteMemory>, I>>(base?: I): WriteMemory {
    return WriteMemory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteMemory>, I>>(object: I): WriteMemory {
    const message = createBaseWriteMemory();
    message.address = object.address ?? BigInt("0");
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWriteMemoryResult(): WriteMemoryResult {
  return { status: 0, address: BigInt("0"), size: BigInt("0") };
}

export const WriteMemoryResult: MessageFns<WriteMemoryResult> = {
  encode(message: WriteMemoryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(16).uint64(message.address);
    }
    if (message.size !== BigInt("0")) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(24).uint64(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteMemoryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteMemoryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteMemoryResult {
    return {
      status: isSet(object.status) ? writeMemoryResult_StatusFromJSON(object.status) : 0,
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      size: isSet(object.size) ? BigInt(object.size) : BigInt("0"),
    };
  },

  toJSON(message: WriteMemoryResult): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = writeMemoryResult_StatusToJSON(message.status);
    }
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.size !== BigInt("0")) {
      obj.size = message.size.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteMemoryResult>, I>>(base?: I): WriteMemoryResult {
    return WriteMemoryResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteMemoryResult>, I>>(object: I): WriteMemoryResult {
    const message = createBaseWriteMemoryResult();
    message.status = object.status ?? 0;
    message.address = object.address ?? BigInt("0");
    message.size = object.size ?? BigInt("0");
    return message;
  },
};

function createBaseGetClassDetails(): GetClassDetails {
  return { classInfo: undefined };
}

export const GetClassDetails: MessageFns<GetClassDetails> = {
  encode(message: GetClassDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.classInfo !== undefined) {
      ProtoClassInfo.encode(message.classInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClassDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClassDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.classInfo = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClassDetails {
    return { classInfo: isSet(object.classInfo) ? ProtoClassInfo.fromJSON(object.classInfo) : undefined };
  },

  toJSON(message: GetClassDetails): unknown {
    const obj: any = {};
    if (message.classInfo !== undefined) {
      obj.classInfo = ProtoClassInfo.toJSON(message.classInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClassDetails>, I>>(base?: I): GetClassDetails {
    return GetClassDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClassDetails>, I>>(object: I): GetClassDetails {
    const message = createBaseGetClassDetails();
    message.classInfo = (object.classInfo !== undefined && object.classInfo !== null)
      ? ProtoClassInfo.fromPartial(object.classInfo)
      : undefined;
    return message;
  },
};

function createBaseGetClassDetailsResult(): GetClassDetailsResult {
  return { classDetails: undefined };
}

export const GetClassDetailsResult: MessageFns<GetClassDetailsResult> = {
  encode(message: GetClassDetailsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.classDetails !== undefined) {
      ProtoClassDetails.encode(message.classDetails, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClassDetailsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClassDetailsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.classDetails = ProtoClassDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClassDetailsResult {
    return { classDetails: isSet(object.classDetails) ? ProtoClassDetails.fromJSON(object.classDetails) : undefined };
  },

  toJSON(message: GetClassDetailsResult): unknown {
    const obj: any = {};
    if (message.classDetails !== undefined) {
      obj.classDetails = ProtoClassDetails.toJSON(message.classDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClassDetailsResult>, I>>(base?: I): GetClassDetailsResult {
    return GetClassDetailsResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClassDetailsResult>, I>>(object: I): GetClassDetailsResult {
    const message = createBaseGetClassDetailsResult();
    message.classDetails = (object.classDetails !== undefined && object.classDetails !== null)
      ? ProtoClassDetails.fromPartial(object.classDetails)
      : undefined;
    return message;
  },
};

function createBaseGetInstanceClass(): GetInstanceClass {
  return { address: BigInt("0") };
}

export const GetInstanceClass: MessageFns<GetInstanceClass> = {
  encode(message: GetInstanceClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceClass {
    return { address: isSet(object.address) ? BigInt(object.address) : BigInt("0") };
  },

  toJSON(message: GetInstanceClass): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstanceClass>, I>>(base?: I): GetInstanceClass {
    return GetInstanceClass.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstanceClass>, I>>(object: I): GetInstanceClass {
    const message = createBaseGetInstanceClass();
    message.address = object.address ?? BigInt("0");
    return message;
  },
};

function createBaseGetInstanceClassResult(): GetInstanceClassResult {
  return { classInfo: undefined };
}

export const GetInstanceClassResult: MessageFns<GetInstanceClassResult> = {
  encode(message: GetInstanceClassResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.classInfo !== undefined) {
      ProtoClassInfo.encode(message.classInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceClassResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceClassResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.classInfo = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceClassResult {
    return { classInfo: isSet(object.classInfo) ? ProtoClassInfo.fromJSON(object.classInfo) : undefined };
  },

  toJSON(message: GetInstanceClassResult): unknown {
    const obj: any = {};
    if (message.classInfo !== undefined) {
      obj.classInfo = ProtoClassInfo.toJSON(message.classInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstanceClassResult>, I>>(base?: I): GetInstanceClassResult {
    return GetInstanceClassResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstanceClassResult>, I>>(object: I): GetInstanceClassResult {
    const message = createBaseGetInstanceClassResult();
    message.classInfo = (object.classInfo !== undefined && object.classInfo !== null)
      ? ProtoClassInfo.fromPartial(object.classInfo)
      : undefined;
    return message;
  },
};

function createBaseGetInstanceValues(): GetInstanceValues {
  return { instance: undefined };
}

export const GetInstanceValues: MessageFns<GetInstanceValues> = {
  encode(message: GetInstanceValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== undefined) {
      ProtoDataPayload.encode(message.instance, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instance = ProtoDataPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceValues {
    return { instance: isSet(object.instance) ? ProtoDataPayload.fromJSON(object.instance) : undefined };
  },

  toJSON(message: GetInstanceValues): unknown {
    const obj: any = {};
    if (message.instance !== undefined) {
      obj.instance = ProtoDataPayload.toJSON(message.instance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstanceValues>, I>>(base?: I): GetInstanceValues {
    return GetInstanceValues.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstanceValues>, I>>(object: I): GetInstanceValues {
    const message = createBaseGetInstanceValues();
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? ProtoDataPayload.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseGetInstanceValuesResult(): GetInstanceValuesResult {
  return { values: [] };
}

export const GetInstanceValuesResult: MessageFns<GetInstanceValuesResult> = {
  encode(message: GetInstanceValuesResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      GetInstanceValuesResult_ValuePair.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceValuesResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceValuesResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(GetInstanceValuesResult_ValuePair.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceValuesResult {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => GetInstanceValuesResult_ValuePair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetInstanceValuesResult): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => GetInstanceValuesResult_ValuePair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstanceValuesResult>, I>>(base?: I): GetInstanceValuesResult {
    return GetInstanceValuesResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstanceValuesResult>, I>>(object: I): GetInstanceValuesResult {
    const message = createBaseGetInstanceValuesResult();
    message.values = object.values?.map((e) => GetInstanceValuesResult_ValuePair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetInstanceValuesResult_ValuePair(): GetInstanceValuesResult_ValuePair {
  return { id: BigInt("0"), data: undefined };
}

export const GetInstanceValuesResult_ValuePair: MessageFns<GetInstanceValuesResult_ValuePair> = {
  encode(message: GetInstanceValuesResult_ValuePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== BigInt("0")) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.data !== undefined) {
      ProtoDataSegment.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceValuesResult_ValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceValuesResult_ValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = ProtoDataSegment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceValuesResult_ValuePair {
    return {
      id: isSet(object.id) ? BigInt(object.id) : BigInt("0"),
      data: isSet(object.data) ? ProtoDataSegment.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: GetInstanceValuesResult_ValuePair): unknown {
    const obj: any = {};
    if (message.id !== BigInt("0")) {
      obj.id = message.id.toString();
    }
    if (message.data !== undefined) {
      obj.data = ProtoDataSegment.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstanceValuesResult_ValuePair>, I>>(
    base?: I,
  ): GetInstanceValuesResult_ValuePair {
    return GetInstanceValuesResult_ValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstanceValuesResult_ValuePair>, I>>(
    object: I,
  ): GetInstanceValuesResult_ValuePair {
    const message = createBaseGetInstanceValuesResult_ValuePair();
    message.id = object.id ?? BigInt("0");
    message.data = (object.data !== undefined && object.data !== null)
      ? ProtoDataSegment.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseCreateGameObject(): CreateGameObject {
  return { name: "", parent: undefined };
}

export const CreateGameObject: MessageFns<CreateGameObject> = {
  encode(message: CreateGameObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== undefined) {
      if (BigInt.asUintN(64, message.parent) !== message.parent) {
        throw new globalThis.Error("value provided for field message.parent of type uint64 too large");
      }
      writer.uint32(16).uint64(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGameObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGameObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.parent = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGameObject {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? BigInt(object.parent) : undefined,
    };
  },

  toJSON(message: CreateGameObject): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== undefined) {
      obj.parent = message.parent.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGameObject>, I>>(base?: I): CreateGameObject {
    return CreateGameObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGameObject>, I>>(object: I): CreateGameObject {
    const message = createBaseCreateGameObject();
    message.name = object.name ?? "";
    message.parent = object.parent ?? undefined;
    return message;
  },
};

function createBaseCreateGameObjectResult(): CreateGameObjectResult {
  return {};
}

export const CreateGameObjectResult: MessageFns<CreateGameObjectResult> = {
  encode(_: CreateGameObjectResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGameObjectResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGameObjectResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateGameObjectResult {
    return {};
  },

  toJSON(_: CreateGameObjectResult): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGameObjectResult>, I>>(base?: I): CreateGameObjectResult {
    return CreateGameObjectResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGameObjectResult>, I>>(_: I): CreateGameObjectResult {
    const message = createBaseCreateGameObjectResult();
    return message;
  },
};

function createBaseAddSafePtrAddress(): AddSafePtrAddress {
  return { address: BigInt("0"), remove: false };
}

export const AddSafePtrAddress: MessageFns<AddSafePtrAddress> = {
  encode(message: AddSafePtrAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.remove !== false) {
      writer.uint32(16).bool(message.remove);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddSafePtrAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSafePtrAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.remove = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSafePtrAddress {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      remove: isSet(object.remove) ? globalThis.Boolean(object.remove) : false,
    };
  },

  toJSON(message: AddSafePtrAddress): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.remove !== false) {
      obj.remove = message.remove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSafePtrAddress>, I>>(base?: I): AddSafePtrAddress {
    return AddSafePtrAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSafePtrAddress>, I>>(object: I): AddSafePtrAddress {
    const message = createBaseAddSafePtrAddress();
    message.address = object.address ?? BigInt("0");
    message.remove = object.remove ?? false;
    return message;
  },
};

function createBaseGetSafePtrAddresses(): GetSafePtrAddresses {
  return {};
}

export const GetSafePtrAddresses: MessageFns<GetSafePtrAddresses> = {
  encode(_: GetSafePtrAddresses, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSafePtrAddresses {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSafePtrAddresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetSafePtrAddresses {
    return {};
  },

  toJSON(_: GetSafePtrAddresses): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSafePtrAddresses>, I>>(base?: I): GetSafePtrAddresses {
    return GetSafePtrAddresses.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSafePtrAddresses>, I>>(_: I): GetSafePtrAddresses {
    const message = createBaseGetSafePtrAddresses();
    return message;
  },
};

function createBaseGetSafePtrAddressesResult(): GetSafePtrAddressesResult {
  return { addresses: [] };
}

export const GetSafePtrAddressesResult: MessageFns<GetSafePtrAddressesResult> = {
  encode(message: GetSafePtrAddressesResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      GetSafePtrAddressesResult_AddressInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSafePtrAddressesResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSafePtrAddressesResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(GetSafePtrAddressesResult_AddressInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSafePtrAddressesResult {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => GetSafePtrAddressesResult_AddressInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSafePtrAddressesResult): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => GetSafePtrAddressesResult_AddressInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSafePtrAddressesResult>, I>>(base?: I): GetSafePtrAddressesResult {
    return GetSafePtrAddressesResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSafePtrAddressesResult>, I>>(object: I): GetSafePtrAddressesResult {
    const message = createBaseGetSafePtrAddressesResult();
    message.addresses = object.addresses?.map((e) => GetSafePtrAddressesResult_AddressInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSafePtrAddressesResult_AddressInfo(): GetSafePtrAddressesResult_AddressInfo {
  return { address: BigInt("0"), clazz: undefined };
}

export const GetSafePtrAddressesResult_AddressInfo: MessageFns<GetSafePtrAddressesResult_AddressInfo> = {
  encode(message: GetSafePtrAddressesResult_AddressInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== BigInt("0")) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(8).uint64(message.address);
    }
    if (message.clazz !== undefined) {
      ProtoClassInfo.encode(message.clazz, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSafePtrAddressesResult_AddressInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSafePtrAddressesResult_AddressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clazz = ProtoClassInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSafePtrAddressesResult_AddressInfo {
    return {
      address: isSet(object.address) ? BigInt(object.address) : BigInt("0"),
      clazz: isSet(object.clazz) ? ProtoClassInfo.fromJSON(object.clazz) : undefined,
    };
  },

  toJSON(message: GetSafePtrAddressesResult_AddressInfo): unknown {
    const obj: any = {};
    if (message.address !== BigInt("0")) {
      obj.address = message.address.toString();
    }
    if (message.clazz !== undefined) {
      obj.clazz = ProtoClassInfo.toJSON(message.clazz);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSafePtrAddressesResult_AddressInfo>, I>>(
    base?: I,
  ): GetSafePtrAddressesResult_AddressInfo {
    return GetSafePtrAddressesResult_AddressInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSafePtrAddressesResult_AddressInfo>, I>>(
    object: I,
  ): GetSafePtrAddressesResult_AddressInfo {
    const message = createBaseGetSafePtrAddressesResult_AddressInfo();
    message.address = object.address ?? BigInt("0");
    message.clazz = (object.clazz !== undefined && object.clazz !== null)
      ? ProtoClassInfo.fromPartial(object.clazz)
      : undefined;
    return message;
  },
};

function createBaseGetTypeComplete(): GetTypeComplete {
  return { namespaze: undefined, clazz: undefined };
}

export const GetTypeComplete: MessageFns<GetTypeComplete> = {
  encode(message: GetTypeComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespaze !== undefined) {
      writer.uint32(10).string(message.namespaze);
    }
    if (message.clazz !== undefined) {
      writer.uint32(18).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTypeComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTypeComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespaze = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTypeComplete {
    return {
      namespaze: isSet(object.namespaze) ? globalThis.String(object.namespaze) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : undefined,
    };
  },

  toJSON(message: GetTypeComplete): unknown {
    const obj: any = {};
    if (message.namespaze !== undefined) {
      obj.namespaze = message.namespaze;
    }
    if (message.clazz !== undefined) {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTypeComplete>, I>>(base?: I): GetTypeComplete {
    return GetTypeComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTypeComplete>, I>>(object: I): GetTypeComplete {
    const message = createBaseGetTypeComplete();
    message.namespaze = object.namespaze ?? undefined;
    message.clazz = object.clazz ?? undefined;
    return message;
  },
};

function createBaseGetTypeCompleteResult(): GetTypeCompleteResult {
  return { options: [] };
}

export const GetTypeCompleteResult: MessageFns<GetTypeCompleteResult> = {
  encode(message: GetTypeCompleteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.options) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTypeCompleteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTypeCompleteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.options.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTypeCompleteResult {
    return {
      options: globalThis.Array.isArray(object?.options) ? object.options.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetTypeCompleteResult): unknown {
    const obj: any = {};
    if (message.options?.length) {
      obj.options = message.options;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTypeCompleteResult>, I>>(base?: I): GetTypeCompleteResult {
    return GetTypeCompleteResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTypeCompleteResult>, I>>(object: I): GetTypeCompleteResult {
    const message = createBaseGetTypeCompleteResult();
    message.options = object.options?.map((e) => e) || [];
    return message;
  },
};

function createBasePacketWrapper(): PacketWrapper {
  return { queryResultId: BigInt("0"), Packet: undefined };
}

export const PacketWrapper: MessageFns<PacketWrapper> = {
  encode(message: PacketWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryResultId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.queryResultId) !== message.queryResultId) {
        throw new globalThis.Error("value provided for field message.queryResultId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.queryResultId);
    }
    switch (message.Packet?.$case) {
      case "inputError":
        writer.uint32(18).string(message.Packet.inputError);
        break;
      case "setField":
        SetField.encode(message.Packet.setField, writer.uint32(26).fork()).join();
        break;
      case "setFieldResult":
        SetFieldResult.encode(message.Packet.setFieldResult, writer.uint32(34).fork()).join();
        break;
      case "getField":
        GetField.encode(message.Packet.getField, writer.uint32(42).fork()).join();
        break;
      case "getFieldResult":
        GetFieldResult.encode(message.Packet.getFieldResult, writer.uint32(50).fork()).join();
        break;
      case "invokeMethod":
        InvokeMethod.encode(message.Packet.invokeMethod, writer.uint32(58).fork()).join();
        break;
      case "invokeMethodResult":
        InvokeMethodResult.encode(message.Packet.invokeMethodResult, writer.uint32(66).fork()).join();
        break;
      case "searchObjects":
        SearchObjects.encode(message.Packet.searchObjects, writer.uint32(74).fork()).join();
        break;
      case "searchObjectsResult":
        SearchObjectsResult.encode(message.Packet.searchObjectsResult, writer.uint32(82).fork()).join();
        break;
      case "getAllGameObjects":
        GetAllGameObjects.encode(message.Packet.getAllGameObjects, writer.uint32(90).fork()).join();
        break;
      case "getAllGameObjectsResult":
        GetAllGameObjectsResult.encode(message.Packet.getAllGameObjectsResult, writer.uint32(98).fork()).join();
        break;
      case "getGameObjectComponents":
        GetGameObjectComponents.encode(message.Packet.getGameObjectComponents, writer.uint32(106).fork()).join();
        break;
      case "getGameObjectComponentsResult":
        GetGameObjectComponentsResult.encode(message.Packet.getGameObjectComponentsResult, writer.uint32(114).fork())
          .join();
        break;
      case "readMemory":
        ReadMemory.encode(message.Packet.readMemory, writer.uint32(122).fork()).join();
        break;
      case "readMemoryResult":
        ReadMemoryResult.encode(message.Packet.readMemoryResult, writer.uint32(130).fork()).join();
        break;
      case "writeMemory":
        WriteMemory.encode(message.Packet.writeMemory, writer.uint32(138).fork()).join();
        break;
      case "writeMemoryResult":
        WriteMemoryResult.encode(message.Packet.writeMemoryResult, writer.uint32(146).fork()).join();
        break;
      case "getClassDetails":
        GetClassDetails.encode(message.Packet.getClassDetails, writer.uint32(154).fork()).join();
        break;
      case "getClassDetailsResult":
        GetClassDetailsResult.encode(message.Packet.getClassDetailsResult, writer.uint32(162).fork()).join();
        break;
      case "getInstanceClass":
        GetInstanceClass.encode(message.Packet.getInstanceClass, writer.uint32(170).fork()).join();
        break;
      case "getInstanceClassResult":
        GetInstanceClassResult.encode(message.Packet.getInstanceClassResult, writer.uint32(178).fork()).join();
        break;
      case "getInstanceValues":
        GetInstanceValues.encode(message.Packet.getInstanceValues, writer.uint32(186).fork()).join();
        break;
      case "getInstanceValuesResult":
        GetInstanceValuesResult.encode(message.Packet.getInstanceValuesResult, writer.uint32(194).fork()).join();
        break;
      case "createGameObject":
        CreateGameObject.encode(message.Packet.createGameObject, writer.uint32(218).fork()).join();
        break;
      case "createGameObjectResult":
        CreateGameObjectResult.encode(message.Packet.createGameObjectResult, writer.uint32(226).fork()).join();
        break;
      case "addSafePtrAddress":
        AddSafePtrAddress.encode(message.Packet.addSafePtrAddress, writer.uint32(234).fork()).join();
        break;
      case "getSafePtrAddresses":
        GetSafePtrAddresses.encode(message.Packet.getSafePtrAddresses, writer.uint32(242).fork()).join();
        break;
      case "getSafePtrAddressesResult":
        GetSafePtrAddressesResult.encode(message.Packet.getSafePtrAddressesResult, writer.uint32(250).fork()).join();
        break;
      case "getTypeComplete":
        GetTypeComplete.encode(message.Packet.getTypeComplete, writer.uint32(258).fork()).join();
        break;
      case "getTypeCompleteResult":
        GetTypeCompleteResult.encode(message.Packet.getTypeCompleteResult, writer.uint32(266).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketWrapper {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketWrapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.queryResultId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Packet = { $case: "inputError", inputError: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Packet = { $case: "setField", setField: SetField.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.Packet = { $case: "setFieldResult", setFieldResult: SetFieldResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.Packet = { $case: "getField", getField: GetField.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.Packet = { $case: "getFieldResult", getFieldResult: GetFieldResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.Packet = { $case: "invokeMethod", invokeMethod: InvokeMethod.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.Packet = {
            $case: "invokeMethodResult",
            invokeMethodResult: InvokeMethodResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.Packet = { $case: "searchObjects", searchObjects: SearchObjects.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.Packet = {
            $case: "searchObjectsResult",
            searchObjectsResult: SearchObjectsResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.Packet = {
            $case: "getAllGameObjects",
            getAllGameObjects: GetAllGameObjects.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.Packet = {
            $case: "getAllGameObjectsResult",
            getAllGameObjectsResult: GetAllGameObjectsResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.Packet = {
            $case: "getGameObjectComponents",
            getGameObjectComponents: GetGameObjectComponents.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.Packet = {
            $case: "getGameObjectComponentsResult",
            getGameObjectComponentsResult: GetGameObjectComponentsResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.Packet = { $case: "readMemory", readMemory: ReadMemory.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.Packet = {
            $case: "readMemoryResult",
            readMemoryResult: ReadMemoryResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.Packet = { $case: "writeMemory", writeMemory: WriteMemory.decode(reader, reader.uint32()) };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.Packet = {
            $case: "writeMemoryResult",
            writeMemoryResult: WriteMemoryResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.Packet = {
            $case: "getClassDetails",
            getClassDetails: GetClassDetails.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.Packet = {
            $case: "getClassDetailsResult",
            getClassDetailsResult: GetClassDetailsResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.Packet = {
            $case: "getInstanceClass",
            getInstanceClass: GetInstanceClass.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.Packet = {
            $case: "getInstanceClassResult",
            getInstanceClassResult: GetInstanceClassResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.Packet = {
            $case: "getInstanceValues",
            getInstanceValues: GetInstanceValues.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.Packet = {
            $case: "getInstanceValuesResult",
            getInstanceValuesResult: GetInstanceValuesResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.Packet = {
            $case: "createGameObject",
            createGameObject: CreateGameObject.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.Packet = {
            $case: "createGameObjectResult",
            createGameObjectResult: CreateGameObjectResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.Packet = {
            $case: "addSafePtrAddress",
            addSafePtrAddress: AddSafePtrAddress.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.Packet = {
            $case: "getSafePtrAddresses",
            getSafePtrAddresses: GetSafePtrAddresses.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.Packet = {
            $case: "getSafePtrAddressesResult",
            getSafePtrAddressesResult: GetSafePtrAddressesResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.Packet = {
            $case: "getTypeComplete",
            getTypeComplete: GetTypeComplete.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.Packet = {
            $case: "getTypeCompleteResult",
            getTypeCompleteResult: GetTypeCompleteResult.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketWrapper {
    return {
      queryResultId: isSet(object.queryResultId) ? BigInt(object.queryResultId) : BigInt("0"),
      Packet: isSet(object.inputError)
        ? { $case: "inputError", inputError: globalThis.String(object.inputError) }
        : isSet(object.setField)
        ? { $case: "setField", setField: SetField.fromJSON(object.setField) }
        : isSet(object.setFieldResult)
        ? { $case: "setFieldResult", setFieldResult: SetFieldResult.fromJSON(object.setFieldResult) }
        : isSet(object.getField)
        ? { $case: "getField", getField: GetField.fromJSON(object.getField) }
        : isSet(object.getFieldResult)
        ? { $case: "getFieldResult", getFieldResult: GetFieldResult.fromJSON(object.getFieldResult) }
        : isSet(object.invokeMethod)
        ? { $case: "invokeMethod", invokeMethod: InvokeMethod.fromJSON(object.invokeMethod) }
        : isSet(object.invokeMethodResult)
        ? { $case: "invokeMethodResult", invokeMethodResult: InvokeMethodResult.fromJSON(object.invokeMethodResult) }
        : isSet(object.searchObjects)
        ? { $case: "searchObjects", searchObjects: SearchObjects.fromJSON(object.searchObjects) }
        : isSet(object.searchObjectsResult)
        ? {
          $case: "searchObjectsResult",
          searchObjectsResult: SearchObjectsResult.fromJSON(object.searchObjectsResult),
        }
        : isSet(object.getAllGameObjects)
        ? { $case: "getAllGameObjects", getAllGameObjects: GetAllGameObjects.fromJSON(object.getAllGameObjects) }
        : isSet(object.getAllGameObjectsResult)
        ? {
          $case: "getAllGameObjectsResult",
          getAllGameObjectsResult: GetAllGameObjectsResult.fromJSON(object.getAllGameObjectsResult),
        }
        : isSet(object.getGameObjectComponents)
        ? {
          $case: "getGameObjectComponents",
          getGameObjectComponents: GetGameObjectComponents.fromJSON(object.getGameObjectComponents),
        }
        : isSet(object.getGameObjectComponentsResult)
        ? {
          $case: "getGameObjectComponentsResult",
          getGameObjectComponentsResult: GetGameObjectComponentsResult.fromJSON(object.getGameObjectComponentsResult),
        }
        : isSet(object.readMemory)
        ? { $case: "readMemory", readMemory: ReadMemory.fromJSON(object.readMemory) }
        : isSet(object.readMemoryResult)
        ? { $case: "readMemoryResult", readMemoryResult: ReadMemoryResult.fromJSON(object.readMemoryResult) }
        : isSet(object.writeMemory)
        ? { $case: "writeMemory", writeMemory: WriteMemory.fromJSON(object.writeMemory) }
        : isSet(object.writeMemoryResult)
        ? { $case: "writeMemoryResult", writeMemoryResult: WriteMemoryResult.fromJSON(object.writeMemoryResult) }
        : isSet(object.getClassDetails)
        ? { $case: "getClassDetails", getClassDetails: GetClassDetails.fromJSON(object.getClassDetails) }
        : isSet(object.getClassDetailsResult)
        ? {
          $case: "getClassDetailsResult",
          getClassDetailsResult: GetClassDetailsResult.fromJSON(object.getClassDetailsResult),
        }
        : isSet(object.getInstanceClass)
        ? { $case: "getInstanceClass", getInstanceClass: GetInstanceClass.fromJSON(object.getInstanceClass) }
        : isSet(object.getInstanceClassResult)
        ? {
          $case: "getInstanceClassResult",
          getInstanceClassResult: GetInstanceClassResult.fromJSON(object.getInstanceClassResult),
        }
        : isSet(object.getInstanceValues)
        ? { $case: "getInstanceValues", getInstanceValues: GetInstanceValues.fromJSON(object.getInstanceValues) }
        : isSet(object.getInstanceValuesResult)
        ? {
          $case: "getInstanceValuesResult",
          getInstanceValuesResult: GetInstanceValuesResult.fromJSON(object.getInstanceValuesResult),
        }
        : isSet(object.createGameObject)
        ? { $case: "createGameObject", createGameObject: CreateGameObject.fromJSON(object.createGameObject) }
        : isSet(object.createGameObjectResult)
        ? {
          $case: "createGameObjectResult",
          createGameObjectResult: CreateGameObjectResult.fromJSON(object.createGameObjectResult),
        }
        : isSet(object.addSafePtrAddress)
        ? { $case: "addSafePtrAddress", addSafePtrAddress: AddSafePtrAddress.fromJSON(object.addSafePtrAddress) }
        : isSet(object.getSafePtrAddresses)
        ? {
          $case: "getSafePtrAddresses",
          getSafePtrAddresses: GetSafePtrAddresses.fromJSON(object.getSafePtrAddresses),
        }
        : isSet(object.getSafePtrAddressesResult)
        ? {
          $case: "getSafePtrAddressesResult",
          getSafePtrAddressesResult: GetSafePtrAddressesResult.fromJSON(object.getSafePtrAddressesResult),
        }
        : isSet(object.getTypeComplete)
        ? { $case: "getTypeComplete", getTypeComplete: GetTypeComplete.fromJSON(object.getTypeComplete) }
        : isSet(object.getTypeCompleteResult)
        ? {
          $case: "getTypeCompleteResult",
          getTypeCompleteResult: GetTypeCompleteResult.fromJSON(object.getTypeCompleteResult),
        }
        : undefined,
    };
  },

  toJSON(message: PacketWrapper): unknown {
    const obj: any = {};
    if (message.queryResultId !== BigInt("0")) {
      obj.queryResultId = message.queryResultId.toString();
    }
    if (message.Packet?.$case === "inputError") {
      obj.inputError = message.Packet.inputError;
    } else if (message.Packet?.$case === "setField") {
      obj.setField = SetField.toJSON(message.Packet.setField);
    } else if (message.Packet?.$case === "setFieldResult") {
      obj.setFieldResult = SetFieldResult.toJSON(message.Packet.setFieldResult);
    } else if (message.Packet?.$case === "getField") {
      obj.getField = GetField.toJSON(message.Packet.getField);
    } else if (message.Packet?.$case === "getFieldResult") {
      obj.getFieldResult = GetFieldResult.toJSON(message.Packet.getFieldResult);
    } else if (message.Packet?.$case === "invokeMethod") {
      obj.invokeMethod = InvokeMethod.toJSON(message.Packet.invokeMethod);
    } else if (message.Packet?.$case === "invokeMethodResult") {
      obj.invokeMethodResult = InvokeMethodResult.toJSON(message.Packet.invokeMethodResult);
    } else if (message.Packet?.$case === "searchObjects") {
      obj.searchObjects = SearchObjects.toJSON(message.Packet.searchObjects);
    } else if (message.Packet?.$case === "searchObjectsResult") {
      obj.searchObjectsResult = SearchObjectsResult.toJSON(message.Packet.searchObjectsResult);
    } else if (message.Packet?.$case === "getAllGameObjects") {
      obj.getAllGameObjects = GetAllGameObjects.toJSON(message.Packet.getAllGameObjects);
    } else if (message.Packet?.$case === "getAllGameObjectsResult") {
      obj.getAllGameObjectsResult = GetAllGameObjectsResult.toJSON(message.Packet.getAllGameObjectsResult);
    } else if (message.Packet?.$case === "getGameObjectComponents") {
      obj.getGameObjectComponents = GetGameObjectComponents.toJSON(message.Packet.getGameObjectComponents);
    } else if (message.Packet?.$case === "getGameObjectComponentsResult") {
      obj.getGameObjectComponentsResult = GetGameObjectComponentsResult.toJSON(
        message.Packet.getGameObjectComponentsResult,
      );
    } else if (message.Packet?.$case === "readMemory") {
      obj.readMemory = ReadMemory.toJSON(message.Packet.readMemory);
    } else if (message.Packet?.$case === "readMemoryResult") {
      obj.readMemoryResult = ReadMemoryResult.toJSON(message.Packet.readMemoryResult);
    } else if (message.Packet?.$case === "writeMemory") {
      obj.writeMemory = WriteMemory.toJSON(message.Packet.writeMemory);
    } else if (message.Packet?.$case === "writeMemoryResult") {
      obj.writeMemoryResult = WriteMemoryResult.toJSON(message.Packet.writeMemoryResult);
    } else if (message.Packet?.$case === "getClassDetails") {
      obj.getClassDetails = GetClassDetails.toJSON(message.Packet.getClassDetails);
    } else if (message.Packet?.$case === "getClassDetailsResult") {
      obj.getClassDetailsResult = GetClassDetailsResult.toJSON(message.Packet.getClassDetailsResult);
    } else if (message.Packet?.$case === "getInstanceClass") {
      obj.getInstanceClass = GetInstanceClass.toJSON(message.Packet.getInstanceClass);
    } else if (message.Packet?.$case === "getInstanceClassResult") {
      obj.getInstanceClassResult = GetInstanceClassResult.toJSON(message.Packet.getInstanceClassResult);
    } else if (message.Packet?.$case === "getInstanceValues") {
      obj.getInstanceValues = GetInstanceValues.toJSON(message.Packet.getInstanceValues);
    } else if (message.Packet?.$case === "getInstanceValuesResult") {
      obj.getInstanceValuesResult = GetInstanceValuesResult.toJSON(message.Packet.getInstanceValuesResult);
    } else if (message.Packet?.$case === "createGameObject") {
      obj.createGameObject = CreateGameObject.toJSON(message.Packet.createGameObject);
    } else if (message.Packet?.$case === "createGameObjectResult") {
      obj.createGameObjectResult = CreateGameObjectResult.toJSON(message.Packet.createGameObjectResult);
    } else if (message.Packet?.$case === "addSafePtrAddress") {
      obj.addSafePtrAddress = AddSafePtrAddress.toJSON(message.Packet.addSafePtrAddress);
    } else if (message.Packet?.$case === "getSafePtrAddresses") {
      obj.getSafePtrAddresses = GetSafePtrAddresses.toJSON(message.Packet.getSafePtrAddresses);
    } else if (message.Packet?.$case === "getSafePtrAddressesResult") {
      obj.getSafePtrAddressesResult = GetSafePtrAddressesResult.toJSON(message.Packet.getSafePtrAddressesResult);
    } else if (message.Packet?.$case === "getTypeComplete") {
      obj.getTypeComplete = GetTypeComplete.toJSON(message.Packet.getTypeComplete);
    } else if (message.Packet?.$case === "getTypeCompleteResult") {
      obj.getTypeCompleteResult = GetTypeCompleteResult.toJSON(message.Packet.getTypeCompleteResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketWrapper>, I>>(base?: I): PacketWrapper {
    return PacketWrapper.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketWrapper>, I>>(object: I): PacketWrapper {
    const message = createBasePacketWrapper();
    message.queryResultId = object.queryResultId ?? BigInt("0");
    switch (object.Packet?.$case) {
      case "inputError": {
        if (object.Packet?.inputError !== undefined && object.Packet?.inputError !== null) {
          message.Packet = { $case: "inputError", inputError: object.Packet.inputError };
        }
        break;
      }
      case "setField": {
        if (object.Packet?.setField !== undefined && object.Packet?.setField !== null) {
          message.Packet = { $case: "setField", setField: SetField.fromPartial(object.Packet.setField) };
        }
        break;
      }
      case "setFieldResult": {
        if (object.Packet?.setFieldResult !== undefined && object.Packet?.setFieldResult !== null) {
          message.Packet = {
            $case: "setFieldResult",
            setFieldResult: SetFieldResult.fromPartial(object.Packet.setFieldResult),
          };
        }
        break;
      }
      case "getField": {
        if (object.Packet?.getField !== undefined && object.Packet?.getField !== null) {
          message.Packet = { $case: "getField", getField: GetField.fromPartial(object.Packet.getField) };
        }
        break;
      }
      case "getFieldResult": {
        if (object.Packet?.getFieldResult !== undefined && object.Packet?.getFieldResult !== null) {
          message.Packet = {
            $case: "getFieldResult",
            getFieldResult: GetFieldResult.fromPartial(object.Packet.getFieldResult),
          };
        }
        break;
      }
      case "invokeMethod": {
        if (object.Packet?.invokeMethod !== undefined && object.Packet?.invokeMethod !== null) {
          message.Packet = {
            $case: "invokeMethod",
            invokeMethod: InvokeMethod.fromPartial(object.Packet.invokeMethod),
          };
        }
        break;
      }
      case "invokeMethodResult": {
        if (object.Packet?.invokeMethodResult !== undefined && object.Packet?.invokeMethodResult !== null) {
          message.Packet = {
            $case: "invokeMethodResult",
            invokeMethodResult: InvokeMethodResult.fromPartial(object.Packet.invokeMethodResult),
          };
        }
        break;
      }
      case "searchObjects": {
        if (object.Packet?.searchObjects !== undefined && object.Packet?.searchObjects !== null) {
          message.Packet = {
            $case: "searchObjects",
            searchObjects: SearchObjects.fromPartial(object.Packet.searchObjects),
          };
        }
        break;
      }
      case "searchObjectsResult": {
        if (object.Packet?.searchObjectsResult !== undefined && object.Packet?.searchObjectsResult !== null) {
          message.Packet = {
            $case: "searchObjectsResult",
            searchObjectsResult: SearchObjectsResult.fromPartial(object.Packet.searchObjectsResult),
          };
        }
        break;
      }
      case "getAllGameObjects": {
        if (object.Packet?.getAllGameObjects !== undefined && object.Packet?.getAllGameObjects !== null) {
          message.Packet = {
            $case: "getAllGameObjects",
            getAllGameObjects: GetAllGameObjects.fromPartial(object.Packet.getAllGameObjects),
          };
        }
        break;
      }
      case "getAllGameObjectsResult": {
        if (object.Packet?.getAllGameObjectsResult !== undefined && object.Packet?.getAllGameObjectsResult !== null) {
          message.Packet = {
            $case: "getAllGameObjectsResult",
            getAllGameObjectsResult: GetAllGameObjectsResult.fromPartial(object.Packet.getAllGameObjectsResult),
          };
        }
        break;
      }
      case "getGameObjectComponents": {
        if (object.Packet?.getGameObjectComponents !== undefined && object.Packet?.getGameObjectComponents !== null) {
          message.Packet = {
            $case: "getGameObjectComponents",
            getGameObjectComponents: GetGameObjectComponents.fromPartial(object.Packet.getGameObjectComponents),
          };
        }
        break;
      }
      case "getGameObjectComponentsResult": {
        if (
          object.Packet?.getGameObjectComponentsResult !== undefined &&
          object.Packet?.getGameObjectComponentsResult !== null
        ) {
          message.Packet = {
            $case: "getGameObjectComponentsResult",
            getGameObjectComponentsResult: GetGameObjectComponentsResult.fromPartial(
              object.Packet.getGameObjectComponentsResult,
            ),
          };
        }
        break;
      }
      case "readMemory": {
        if (object.Packet?.readMemory !== undefined && object.Packet?.readMemory !== null) {
          message.Packet = { $case: "readMemory", readMemory: ReadMemory.fromPartial(object.Packet.readMemory) };
        }
        break;
      }
      case "readMemoryResult": {
        if (object.Packet?.readMemoryResult !== undefined && object.Packet?.readMemoryResult !== null) {
          message.Packet = {
            $case: "readMemoryResult",
            readMemoryResult: ReadMemoryResult.fromPartial(object.Packet.readMemoryResult),
          };
        }
        break;
      }
      case "writeMemory": {
        if (object.Packet?.writeMemory !== undefined && object.Packet?.writeMemory !== null) {
          message.Packet = { $case: "writeMemory", writeMemory: WriteMemory.fromPartial(object.Packet.writeMemory) };
        }
        break;
      }
      case "writeMemoryResult": {
        if (object.Packet?.writeMemoryResult !== undefined && object.Packet?.writeMemoryResult !== null) {
          message.Packet = {
            $case: "writeMemoryResult",
            writeMemoryResult: WriteMemoryResult.fromPartial(object.Packet.writeMemoryResult),
          };
        }
        break;
      }
      case "getClassDetails": {
        if (object.Packet?.getClassDetails !== undefined && object.Packet?.getClassDetails !== null) {
          message.Packet = {
            $case: "getClassDetails",
            getClassDetails: GetClassDetails.fromPartial(object.Packet.getClassDetails),
          };
        }
        break;
      }
      case "getClassDetailsResult": {
        if (object.Packet?.getClassDetailsResult !== undefined && object.Packet?.getClassDetailsResult !== null) {
          message.Packet = {
            $case: "getClassDetailsResult",
            getClassDetailsResult: GetClassDetailsResult.fromPartial(object.Packet.getClassDetailsResult),
          };
        }
        break;
      }
      case "getInstanceClass": {
        if (object.Packet?.getInstanceClass !== undefined && object.Packet?.getInstanceClass !== null) {
          message.Packet = {
            $case: "getInstanceClass",
            getInstanceClass: GetInstanceClass.fromPartial(object.Packet.getInstanceClass),
          };
        }
        break;
      }
      case "getInstanceClassResult": {
        if (object.Packet?.getInstanceClassResult !== undefined && object.Packet?.getInstanceClassResult !== null) {
          message.Packet = {
            $case: "getInstanceClassResult",
            getInstanceClassResult: GetInstanceClassResult.fromPartial(object.Packet.getInstanceClassResult),
          };
        }
        break;
      }
      case "getInstanceValues": {
        if (object.Packet?.getInstanceValues !== undefined && object.Packet?.getInstanceValues !== null) {
          message.Packet = {
            $case: "getInstanceValues",
            getInstanceValues: GetInstanceValues.fromPartial(object.Packet.getInstanceValues),
          };
        }
        break;
      }
      case "getInstanceValuesResult": {
        if (object.Packet?.getInstanceValuesResult !== undefined && object.Packet?.getInstanceValuesResult !== null) {
          message.Packet = {
            $case: "getInstanceValuesResult",
            getInstanceValuesResult: GetInstanceValuesResult.fromPartial(object.Packet.getInstanceValuesResult),
          };
        }
        break;
      }
      case "createGameObject": {
        if (object.Packet?.createGameObject !== undefined && object.Packet?.createGameObject !== null) {
          message.Packet = {
            $case: "createGameObject",
            createGameObject: CreateGameObject.fromPartial(object.Packet.createGameObject),
          };
        }
        break;
      }
      case "createGameObjectResult": {
        if (object.Packet?.createGameObjectResult !== undefined && object.Packet?.createGameObjectResult !== null) {
          message.Packet = {
            $case: "createGameObjectResult",
            createGameObjectResult: CreateGameObjectResult.fromPartial(object.Packet.createGameObjectResult),
          };
        }
        break;
      }
      case "addSafePtrAddress": {
        if (object.Packet?.addSafePtrAddress !== undefined && object.Packet?.addSafePtrAddress !== null) {
          message.Packet = {
            $case: "addSafePtrAddress",
            addSafePtrAddress: AddSafePtrAddress.fromPartial(object.Packet.addSafePtrAddress),
          };
        }
        break;
      }
      case "getSafePtrAddresses": {
        if (object.Packet?.getSafePtrAddresses !== undefined && object.Packet?.getSafePtrAddresses !== null) {
          message.Packet = {
            $case: "getSafePtrAddresses",
            getSafePtrAddresses: GetSafePtrAddresses.fromPartial(object.Packet.getSafePtrAddresses),
          };
        }
        break;
      }
      case "getSafePtrAddressesResult": {
        if (
          object.Packet?.getSafePtrAddressesResult !== undefined && object.Packet?.getSafePtrAddressesResult !== null
        ) {
          message.Packet = {
            $case: "getSafePtrAddressesResult",
            getSafePtrAddressesResult: GetSafePtrAddressesResult.fromPartial(object.Packet.getSafePtrAddressesResult),
          };
        }
        break;
      }
      case "getTypeComplete": {
        if (object.Packet?.getTypeComplete !== undefined && object.Packet?.getTypeComplete !== null) {
          message.Packet = {
            $case: "getTypeComplete",
            getTypeComplete: GetTypeComplete.fromPartial(object.Packet.getTypeComplete),
          };
        }
        break;
      }
      case "getTypeCompleteResult": {
        if (object.Packet?.getTypeCompleteResult !== undefined && object.Packet?.getTypeCompleteResult !== null) {
          message.Packet = {
            $case: "getTypeCompleteResult",
            getTypeCompleteResult: GetTypeCompleteResult.fromPartial(object.Packet.getTypeCompleteResult),
          };
        }
        break;
      }
    }
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
